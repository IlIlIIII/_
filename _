local SetHeadless = false
local ShowReanim = false
local BoomBoxName = "BoomBox"
local currentversion = "41"

local schar = game.Players.LocalPlayer.Character
if not schar["Starslayer Railgun"] or not schar["SoloWing"] or not schar["SoloWing2"] or not schar["Evil Aura"] or not schar["Nagamaki"] or not schar["HumanoidRootPart"] then
	game:GetService("StarterGui"):SetCore("SendNotification",{
		Title = "IDHAN",
		Text = "Items and/or RootPart missing!",
		Button1 = "Okay"
	})
	return
end

local HiddenPlace = Instance.new("WorldModel",game)

local HumanRoot = game.Players.LocalPlayer.Character.HumanoidRootPart
local Player = game.Players.LocalPlayer
local VEL = 0
local NOHATS = {}
local SETHATS = {}

local function z()
	workspace.FallenPartsDestroyHeight = -500
	Player.CameraMaxZoomDistance = 400
	local YeOldPos = HumanRoot.CFrame
	HumanRoot.CFrame = CFrame.new(99999,99999,99999)
	wait(game:GetService("Players").RespawnTime - .5)
	HumanRoot.CFrame = YeOldPos * CFrame.new(0,-1,0)
end
coroutine.wrap(z)()

local ReplicationBoombox
local AudioReplication = false
for i,v in pairs(Player.Backpack:GetChildren()) do
	if v:IsA("Tool") and v.Name ~= BoomBoxName then
		v:Destroy()
	else
		v.Parent = Player.Character
		ReplicationBoombox = v
		ReplicationBoombox.Handle.CanCollide = false
		AudioReplication = true
	end
end

Bypass = "death"

HumanDied = false

CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = math.huge;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 900;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = math.huge;
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 900;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL
	local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL
	local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL
	AttachmentC.Orientation = Angle
	AttachmentA.Position = Position
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentC;
	AlignOri.Attachment0 = AttachmentD;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1

end

CountSCIFIMOVIELOLHRP = 1
function SCIFIMOVIELOLHRP(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOLHRP
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = math.huge;
	AlignPos.MaxVelocity = 250000/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 900;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOLHRP
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 250000;
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 900;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOLHRP
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOLHRP
	local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOLHRP
	local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOLHRP
	AttachmentC.Orientation = Angle
	AttachmentA.Position = Position
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentC;
	AlignOri.Attachment0 = AttachmentD;
	CountSCIFIMOVIELOLHRP = CountSCIFIMOVIELOLHRP + 1

end

CountSCIFIMOVIELOLHATS = 1
function SCIFIMOVIELOLHATS(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOLHATS
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = math.huge; --25000
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 900;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOLHATS
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = math.huge; --25000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 900;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOLHATS
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOLHATS
	local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOLHATS
	local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOLHATS
	AttachmentC.Orientation = Angle
	AttachmentA.Position = Position
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentC;
	AlignOri.Attachment0 = AttachmentD;
	CountSCIFIMOVIELOLHATS = CountSCIFIMOVIELOLHATS + 1

end

coroutine.wrap(function()
	local player = game.Players.LocalPlayer
	local char = player.Character or player.CharacterAdded:wait()
	if sethiddenproperty then
		while true do
			game:GetService("RunService").RenderStepped:Wait()
			settings().Physics.AllowSleep = false
			local TBL = game:GetService("Players"):GetChildren() 
			for _ = 1,#TBL do local Players = TBL[_]
				if Players ~= game:GetService("Players").LocalPlayer then
					Players.MaximumSimulationRadius = 0
					sethiddenproperty(Players,"SimulationRadius",0) 
				end 
			end
			game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
			sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.pow(math.huge,math.huge)*math.huge)
			if HumanDied then break end
		end
	else
		while true do
			game:GetService("RunService").RenderStepped:Wait()
			settings().Physics.AllowSleep = false
			local TBL = game:GetService("Players"):GetChildren() 
			for _ = 1,#TBL do local Players = TBL[_]
				if Players ~= game:GetService("Players").LocalPlayer then
					Players.MaximumSimulationRadius = 0
				end 
			end
			game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
			if HumanDied then break end
		end
	end
end)()

if game:GetService("Players").LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
	if Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
		game:GetService("Players").LocalPlayer["Character"].Archivable = true 
		local CloneChar = game:GetService("Players").LocalPlayer["Character"]:Clone()
		game:GetService("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
		game:GetService("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
		game:GetService("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
		local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
		Instance.new("Part",FalseChar).Name = "Head" 
		Instance.new("Part",FalseChar).Name = "Torso" 
		Instance.new("Humanoid",FalseChar).Name = "Humanoid"
		game:GetService("Players").LocalPlayer["Character"] = FalseChar
		game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
		local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
		Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
		Clone.Name = "Humanoid"
		game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
		game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
		game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 
		wait(5.65) 
		game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
		CloneChar.Parent = workspace 
		CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
		wait() 
		CloneChar.Humanoid.BreakJointsOnDeath = false
		workspace.Camera.CameraSubject = CloneChar.Humanoid 
		CloneChar.Name = "non" 
		CloneChar.Humanoid.DisplayDistanceType = "None"
		if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
		if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face"):Destroy() end --if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

		FalseChar:Destroy()

		local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]
		NominatedDeadChar = DeadChar
		local LVecPart = Instance.new("Part", HiddenPlace) LVecPart.CanCollide = false LVecPart.Transparency = 1
		local CONVEC
		local function VECTORUNIT()
			if HumanDied then CONVEC:Disconnect(); return end
			local lookVec = workspace.Camera.CFrame.lookVector
			local Root = CloneChar["HumanoidRootPart"]
			LVecPart.Position = Root.Position
			LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
		end
		CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

		local CONDOWN
		local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
		local function KEYDOWN(_,Processed) 
			if HumanDied then CONDOWN:Disconnect(); return end
			if Processed ~= true then
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = true end
				if Key == Enum.KeyCode.A then
					ADown = true end
				if Key == Enum.KeyCode.S then
					SDown = true end
				if Key == Enum.KeyCode.D then
					DDown = true end
				if Key == Enum.KeyCode.Space then
					SpaceDown = true end end end
		CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

		local CONUP
		local function KEYUP(_)
			if HumanDied then CONUP:Disconnect(); return end
			local Key = _.KeyCode
			if Key == Enum.KeyCode.W then
				WDown = false end
			if Key == Enum.KeyCode.A then
				ADown = false end
			if Key == Enum.KeyCode.S then
				SDown = false end
			if Key == Enum.KeyCode.D then
				DDown = false end
			if Key == Enum.KeyCode.Space then
				SpaceDown = false end end
		CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

		local function MoveClone(X,Y,Z)
			LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
			workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
		end

		coroutine.wrap(function() 
			while true do game:GetService("RunService").RenderStepped:Wait()
				if HumanDied then break end
				if WDown then MoveClone(0,0,1e4) end
				if ADown then MoveClone(1e4,0,0) end
				if SDown then MoveClone(0,0,-1e4) end
				if DDown then MoveClone(-1e4,0,0) end
				if SpaceDown then CloneChar["Humanoid"].Jump = true end
				if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
					CloneChar.Humanoid.WalkToPoint = CloneChar.HumanoidRootPart.Position end
			end 
		end)()

		local con
		function UnCollide()
			if HumanDied then con:Disconnect(); return end
			for _,Parts in next, CloneChar:GetDescendants() do
				if Parts:IsA("BasePart") then
					HumanRoot.CanCollide = false
					Parts.CanCollide = false 
				end 
			end
			for _,Parts in next, DeadChar:GetDescendants() do
				if Parts:IsA("BasePart") then
					Parts.CanCollide = false
					HumanRoot.CanCollide = false
				end 
			end 
		end
		con = game:GetService("RunService").Stepped:Connect(UnCollide)

		FRB = Instance.new("BindableEvent")

		resetBindable = Instance.new("BindableEvent")
		resetBindable.Event:connect(function()
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
			resetBindable:Destroy()
			CloneChar.Humanoid.Health = 0
		end)
		game:GetService("StarterGui"):SetCore("ResetButtonCallback", FRB)

		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
					HumanDied = true
					pcall(function()
						game.Players.LocalPlayer.Character = CloneChar
						CloneChar:Destroy()
						game.Players.LocalPlayer.Character = DeadChar
						if resetBindable then
							game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
							resetBindable:Destroy()
						end
						DeadChar.Humanoid.Health = 0
					end)
					break
				end		
			end
		end)()

		SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		SCIFIMOVIELOLHRP(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))

		for _,v in next, DeadChar:GetChildren() do
			if v:IsA("Accessory") and table.find(SETHATS,v.Handle) == nil then
				SCIFIMOVIELOLHATS(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
			end
		end

		for _,BodyParts in next, CloneChar:GetDescendants() do
			if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
				BodyParts.Transparency = 1 end end
	elseif Bypass == "hats" then
		game:GetService("Players").LocalPlayer["Character"].Archivable = true 
		local DeadChar = game.Players.LocalPlayer.Character
		DeadChar.Name = "non"
		local HatPosition = Vector3.new(0,0,0)
		local HatName = "MediHood"
		local HatsLimb = {
			Rarm = DeadChar:FindFirstChild("Hat1"),
			Larm = DeadChar:FindFirstChild("Pink Hair"),
			Rleg = DeadChar:FindFirstChild("Robloxclassicred"),
			Lleg = DeadChar:FindFirstChild("Kate Hair"),
			Torso1 = DeadChar:FindFirstChild("Pal Hair"),
			Torso2 = DeadChar:FindFirstChild("LavanderHair")
		}
		HatName = DeadChar:FindFirstChild(HatName)

		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
					HumanDied = true
					pcall(function()
						if resetBindable then
							game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
							resetBindable:Destroy()
						end
						DeadChar.Humanoid.Health = 0
					end)
					break
				end		
			end
		end)()

		local con
		function UnCollide()
			if HumanDied then con:Disconnect(); return end
			for _,Parts in next, DeadChar:GetDescendants() do
				if Parts:IsA("BasePart") then
					Parts.CanCollide = false
				end 
			end 
		end
		con = game:GetService("RunService").Stepped:Connect(UnCollide)

		SCIFIMOVIELOL(HatName.Handle,DeadChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		SCIFIMOVIELOL(HatsLimb.Torso1.Handle,DeadChar["Torso"],Vector3.new(0.5,0,0),Vector3.new(90,0,0))
		SCIFIMOVIELOL(HatsLimb.Torso2.Handle,DeadChar["Torso"],Vector3.new(-0.5,0,0),Vector3.new(90,0,0))
		SCIFIMOVIELOL(HatsLimb.Larm.Handle,DeadChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
		SCIFIMOVIELOL(HatsLimb.Rarm.Handle,DeadChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
		SCIFIMOVIELOL(HatsLimb.Lleg.Handle,DeadChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))
		SCIFIMOVIELOL(HatsLimb.Rleg.Handle,DeadChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))

		for i,v in pairs(HatsLimb) do
			v.Handle:FindFirstChild("AccessoryWeld"):Destroy()
			if v.Handle:FindFirstChild("Mesh") then v.Handle:FindFirstChild("Mesh"):Destroy() end
			if v.Handle:FindFirstChild("SpecialMesh") then v.Handle:FindFirstChild("SpecialMesh"):Destroy() end
		end
		HatName.Handle:FindFirstChild("AccessoryWeld"):Destroy()
	end
elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
	game:GetService("Players").LocalPlayer["Character"].Archivable = true 
	local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
	game:GetService("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
	game:GetService("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
	game:GetService("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
	local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
	Instance.new("Part",FalseChar).Name = "Head" 
	Instance.new("Part",FalseChar).Name = "UpperTorso"
	Instance.new("Humanoid",FalseChar).Name = "Humanoid"
	game:GetService("Players").LocalPlayer["Character"] = FalseChar
	game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
	local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
	Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
	Clone.Name = "Humanoid"
	game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
	game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
	game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 
	wait(5.65) 
	game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
	CloneChar.Parent = workspace 
	CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
	wait() 
	CloneChar.Humanoid.BreakJointsOnDeath = false
	workspace.Camera.CameraSubject = CloneChar.Humanoid 
	CloneChar.Name = "non" 
	CloneChar.Humanoid.DisplayDistanceType = "None"
	if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
	if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

	FalseChar:Destroy()

	local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]

	local LVecPart = Instance.new("Part", HiddenPlace) LVecPart.CanCollide = false LVecPart.Transparency = 1
	local CONVEC
	local function VECTORUNIT()
		if HumanDied then CONVEC:Disconnect(); return end
		local lookVec = workspace.Camera.CFrame.lookVector
		local Root = CloneChar["HumanoidRootPart"]
		LVecPart.Position = Root.Position
		LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
	end
	CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

	local CONDOWN
	local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
	local function KEYDOWN(_,Processed) 
		if HumanDied then CONDOWN:Disconnect(); return end
		if Processed ~= true then
			local Key = _.KeyCode
			if Key == Enum.KeyCode.W then
				WDown = true end
			if Key == Enum.KeyCode.A then
				ADown = true end
			if Key == Enum.KeyCode.S then
				SDown = true end
			if Key == Enum.KeyCode.D then
				DDown = true end
			if Key == Enum.KeyCode.Space then
				SpaceDown = true end end end
	CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

	local CONUP
	local function KEYUP(_)
		if HumanDied then CONUP:Disconnect(); return end
		local Key = _.KeyCode
		if Key == Enum.KeyCode.W then
			WDown = false end
		if Key == Enum.KeyCode.A then
			ADown = false end
		if Key == Enum.KeyCode.S then
			SDown = false end
		if Key == Enum.KeyCode.D then
			DDown = false end
		if Key == Enum.KeyCode.Space then
			SpaceDown = false end end
	CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

	local function MoveClone(X,Y,Z)
		LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
		workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
	end

	coroutine.wrap(function() 
		while true do game:GetService("RunService").RenderStepped:Wait()
			if HumanDied then break end
			if WDown then MoveClone(0,0,1e4) end
			if ADown then MoveClone(1e4,0,0) end
			if SDown then MoveClone(0,0,-1e4) end
			if DDown then MoveClone(-1e4,0,0) end
			if SpaceDown then CloneChar["Humanoid"].Jump = true end
			if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
				workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
		end 
	end)()

	local con
	function UnCollide()
		if HumanDied then con:Disconnect(); return end
		for _,Parts in next, CloneChar:GetDescendants() do
			if Parts:IsA("BasePart") then
				Parts.CanCollide = false 
			end 
		end
		for _,Parts in next, DeadChar:GetDescendants() do
			if Parts:IsA("BasePart") then
				Parts.CanCollide = false
			end 
		end 
	end
	con = game:GetService("RunService").Stepped:Connect(UnCollide)

	resetBindable = Instance.new("BindableEvent")
	resetBindable.Event:connect(function()
		game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
		resetBindable:Destroy()
		CloneChar.Humanoid.Health = 0
	end)
	game:GetService("StarterGui"):SetCore("ResetButtonCallback", FRB)

	coroutine.wrap(function()
		while true do
			game:GetService("RunService").RenderStepped:wait()
			if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
				HumanDied = true
				pcall(function()
					game.Players.LocalPlayer.Character = CloneChar
					CloneChar:Destroy()
					game.Players.LocalPlayer.Character = DeadChar
					if resetBindable then
						game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
						resetBindable:Destroy()
					end
					DeadChar.Humanoid.Health = 0
				end)
				break
			end		
		end
	end)()

	for _,v in next, DeadChar:GetChildren() do
		if v:IsA("Accessory") then
			v:Clone().Parent = CloneChar
		end
	end

	SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))

	SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
	SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))

	SCIFIMOVIELOLHRP(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))

	for _,v in next, DeadChar:GetChildren() do
		if v:IsA("Accessory") then
			SCIFIMOVIELOLHATS(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
		end
	end

	for _,BodyParts in next, CloneChar:GetDescendants() do
		if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
			BodyParts.Transparency = 1 end end
	if DeadChar.Head:FindFirstChild("Neck") then
		game.Players.LocalPlayer.Character:BreakJoints()
	end
end



local CloneChar = workspace.non



for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			v.Velocity = Vector3.new(-65,35,-65)
		end)
	end
end

-- Offical Script --
local Player = game:GetService("Players").LocalPlayer
local Character = CloneChar

local FPSCounter = game:GetObjects("rbxassetid://8485510285")[1]
FPSCounter.Parent = Player.PlayerGui


local hgay = Instance.new("Sound",game.Chat)
hgay.SoundId = "rbxassetid://5035412139"
hgay.PlayOnRemove = true
hgay.Volume = 1
hgay:Destroy()

game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = "================================================"},{Color = Color3.fromRGB(184, 42, 255)},{Font = Enum.Font.Arcade},{TextSize = 18})
game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = " "},{Color = Color3.fromRGB(184, 42, 255)},{Font = Enum.Font.Arcade},{TextSize = 18})
game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = "It doesn't have a name, version "..currentversion.." has been loaded."},{Color = Color3.fromRGB(184, 42, 255)},{Font = Enum.Font.Arcade},{TextSize = 18})
game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = " "},{Color = Color3.fromRGB(184, 42, 255)},{Font = Enum.Font.Arcade},{TextSize = 18})
game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = "================================================"},{Color = Color3.fromRGB(184, 42, 255)},{Font = Enum.Font.Arcade},{TextSize = 18})

-- Character Setup --
local Humanoid = Character["Humanoid"]
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Head = Character.Head
local Torso = Character.Torso
local RootPart = Character.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local Neck = Torso["Neck"]
local RightShoulder = Torso["Right Shoulder"]
local LeftShoulder = Torso["Left Shoulder"]
local RightHip = Torso["Right Hip"]
local LeftHip = Torso["Left Hip"]

local ROOTC0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local NECKC0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local RIGHTSHOULDERC0 = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local LEFTSHOULDERC0 = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))

local ThrusterThing = Instance.new("BodyThrust")
ThrusterThing.Parent = HumanRoot
ThrusterThing.Force = Vector3.new(9999999,9999999,9999999)
-- Character Setup --

-- GUN Setup --
local GUN = game:GetObjects("rbxassetid://8479711758")[1]
local GunJoint = GUN.Joint
local Hole = GUN.Hole
local Holetwo = GUN.Hole2
local GunPos = GUN.GunPos
GUN.Parent = Character

-- Gun --

local gunweld = Instance.new("Weld")
gunweld.Parent = GunJoint
gunweld.Part0 = RightArm
gunweld.Part1 = GunJoint
gunweld.C0 = CFrame.new(0*1,-.5*1,0*1)
gunweld.C1 = CFrame.new(0, 0, 0)

local athp1 = Instance.new("Attachment",GunPos)
athp1.Name = "athp1"
local atho1 = Instance.new("Attachment",GunPos)
atho1.Name = "atho1"

Character["Starslayer Railgun"].Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp1
Character["Starslayer Railgun"].Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho1
atho1.Rotation = Vector3.new(0, 90, 45)
athp1.Position = Vector3.new(0, 0, .5)

-- Sword --

local athp7 = Instance.new("Attachment",GunPos)
athp7.Name = "athp7"
local atho7 = Instance.new("Attachment",GunPos)
atho7.Name = "atho7"

Character["MeshPartAccessory"].Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp7
Character["MeshPartAccessory"].Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho7
atho7.Rotation = Vector3.new(0, 90, -145)
athp7.Position = Vector3.new(100, 100, 100)

-- Aura --

local AuraPart = Instance.new("Part")
AuraPart.Parent = Character
AuraPart.Transparency = 1
AuraPart.CanCollide = false

local AuraWeld = Instance.new("Weld")
AuraWeld.Parent = AuraPart
AuraWeld.Part0 = Torso
AuraWeld.Part1 = AuraPart
AuraWeld.C0 = CFrame.new(0, 0, 0)
AuraWeld.C1 = CFrame.new(0, -1.5, -2)


local athp2 = Instance.new("Attachment",AuraPart)
athp2.Name = "athp2"
local atho2 = Instance.new("Attachment",AuraPart)
atho2.Name = "atho2"

Character["Evil Aura"].Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp2
Character["Evil Aura"].Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho2
atho2.Rotation = Vector3.new(90, 0, 0)
athp2.Position = Vector3.new(0, 0, 0)

local LWing = Instance.new("Part")
LWing.Parent = Character
LWing.Size = Vector3.new(4, 1, 2)
LWing.Name = Player.Name.."'s Left Wing Of Madness"
LWing.Anchored = false
LWing.Locked = true
LWing.Transparency = 1
local RWing = Instance.new("Part")
RWing.Parent = Character
RWing.Size = Vector3.new(4, 1, 2)
RWing.Name = Player.Name.."'s Right Wing Of Madness"
RWing.Anchored = false
RWing.Locked = true
RWing.Transparency = 1
local LWingWld = Instance.new("Motor6D")
LWingWld.Parent = LWing
LWingWld.Part0 = Torso
LWingWld.Part1 = LWing
LWingWld.C0 = CFrame.new(-0.25, 0.5, 0.5)CFrame.fromEulerAnglesXYZ(0, 1.57, 0)
LWingWld.C1 = CFrame.new(1.1, 1, 0.95)
local RWingWld = Instance.new("Motor6D")
RWingWld.Parent = RWing
RWingWld.Part0 = Torso
RWingWld.Part1 = RWing
RWingWld.C0 = CFrame.new(0.25, 0.5, 0.5)CFrame.fromEulerAnglesXYZ(0, 1.57, 0)
RWingWld.C1 = CFrame.new(1.1, 1, -0.95)


-- Left wing
local athp3 = Instance.new("Attachment",LWing)
athp3.Name = "athp3"
local atho3 = Instance.new("Attachment",LWing)
atho3.Name = "atho3"

Character["SoloWing"].Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp3
Character["SoloWing"].Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho3
atho3.Rotation = Vector3.new(0, 160, 0)
athp3.Position = Vector3.new(-.5, 1.5, 0.3)


-- Right wing
local athp4 = Instance.new("Attachment",RWing)
athp4.Name = "athp3"
local atho4 = Instance.new("Attachment",RWing)
atho4.Name = "atho3"

Character["SoloWing2"].Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp4
Character["SoloWing2"].Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho4
atho4.Rotation = Vector3.new(0, 20, 0)
athp4.Position = Vector3.new(-.5, 1.5, -.3)


-- GUN Setup --

-- Nametag setup --

local Name = Instance.new("BillboardGui")
local KeepSize = Instance.new("ImageLabel")
local TextHolder = Instance.new("TextBox")
Name.Name = "Name"
Name.Parent = Character
Name.Active = true
Name.AlwaysOnTop = true
Name.Size = UDim2.new(7.5, 0, 5, 0)
Name.StudsOffset = Vector3.new(0, 3, 0)
Name.Adornee = Head
KeepSize.Name = "KeepSize"
KeepSize.Parent = Name
KeepSize.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
KeepSize.BackgroundTransparency = 1.000
KeepSize.Size = UDim2.new(1, 0, 1, 0)
KeepSize.Image = "rbxassetid://145360615"
KeepSize.ImageTransparency = 1.000
TextHolder.Name = "TextHolder"
TextHolder.Parent = KeepSize
TextHolder.AnchorPoint = Vector2.new(0.5, 0.5)
TextHolder.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
TextHolder.BackgroundTransparency = 1.000
TextHolder.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextHolder.Position = UDim2.new(0.5, 0, 0.5, 0)
TextHolder.Size = UDim2.new(0.899999976, 0, 0.5, 0)
TextHolder.ClearTextOnFocus = false
TextHolder.Font = Enum.Font.Arcade
TextHolder.MultiLine = true
TextHolder.PlaceholderColor3 = Color3.fromRGB(50, 50, 50)
TextHolder.Text = ""
TextHolder.TextColor3 = Color3.fromRGB(255, 255, 255)
TextHolder.TextScaled = true
TextHolder.TextSize = 50.000
TextHolder.TextStrokeTransparency = 0.000
TextHolder.TextWrapped = true
TextHolder.TextYAlignment = Enum.TextYAlignment.Bottom

-- Nametag setup --

-- Animation Setup --
local Anim = "Idle"
local Mode = "None"
local attack = false

local eeevol = 5
local HipVal = 3
local eeepitch = 1
local change = 1
local sensitivity = 25
local sine = 0
local Sine = sine
local SINE = sine
local Animation_Speed = 0
-- Animation Setup --

-- Clerp --
function QFCF(cf)
	local mx,my,mz,m00,m01,m02,m10,m11,m12,m20,m21,m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = .5/s
		return (m21 - m12) * recip,(m02 - m20) * recip,(m10 - m01) * recip,s * .5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = .5/s
			return .5 * s,(m10 + m01) * recip,(m20 + m02) * recip,(m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = .5/s
			return (m01 + m10) * recip,.5 * s,(m21 + m12) * recip,(m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = .5/s return (m02 + m20) * recip,(m12 + m21) * recip,.5 * s,(m10 - m01) * recip
		end
	end
end

function QTCF(px,py,pz,x,y,z,w)
	local xs,ys,zs = x + x,y + y,z + z
	local wx,wy,wz = w * xs,w * ys,w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px,py,pz,1 - (yy + zz),xy - wz,xz + wy,xy + wz,1 - (xx + zz),yz - wx,xz - wy,yz + wx,1 - (xx + yy))
end

function QS(a,b,t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp,finishInterp;
	if cosTheta >= .0001 then
		if (1 - cosTheta) > .0001 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1/math.sin(theta)
			startInterp = math.sin((1 - t) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > .0001 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1/math.sin(theta)
			startInterp = math.sin((t - 1) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp,a[2] * startInterp + b[2] * finishInterp,a[3] * startInterp + b[3] * finishInterp,a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a,b,t)
	local qa = {QFCF(a)}
	local qb = {QFCF(b)}
	local ax,ay,az = a.x,a.y,a.z
	local bx,by,bz = b.x,b.y,b.z
	local _t = 1 - t
	return QTCF(_t * ax + t * bx,_t * ay + t * by,_t * az + t * bz,QS(qa,qb,t))
end
-- Clerp --

-- Creat Music Part --

local eeeblock = Instance.new("Part")
eeeblock.Transparency = 1
eeeblock.CanCollide = false

local MusicReal = Instance.new("Sound")
MusicReal.Parent = Torso
MusicReal.Volume = .5
MusicReal.SoundId = "rbxassetid://3979209289"
MusicReal.Looped = true
MusicReal.Playing = true

-- Create Music Part --

-- Anti Void --
local stopeverything = false
local doe = 0
antivoid = Instance.new("Part")
antivoid.Name = "Protection"
antivoid.Size = Vector3.new(400,10,400)
antivoid.Anchored = true
antivoid.Transparency = 1
antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+60,RootPart.Position.Z)
antivoid.Parent = Character
coroutine.resume(coroutine.create(function()
	while wait() do
		if antivoid:IsDescendantOf(workspace) then
			antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+60,RootPart.Position.Z)
		else
			pcall(function()
				antivoid:Destroy()
			end)
			antivoid = Instance.new("Part")
			antivoid.Name = "Protection"
			antivoid.Size = Vector3.new(400,10,400)
			antivoid.Anchored = true
			antivoid.Transparency = 1
			antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+60,RootPart.Position.Z)
			antivoid.Parent = Character
		end
	end
end))

-- Anti Void

-- Some dumb stuff --
-- STuff --
local IT = Instance.new
local CF = CFrame.new
local VT = Vector3.new
local RAD = math.rad
local C3 = Color3.new
local UD2 = UDim2.new
local BRICKC = BrickColor.new
local ANGLES = CFrame.Angles
local EULER = CFrame.fromEulerAnglesXYZ
local COS = math.cos
local SIN = math.sin
local MRANDOM = math.random
local CFA = CFrame.Angles
-- STuff --
local function obunga(a,b,t)
	return a:Lerp(b,math.clamp(t,0,1))
end


function brup(a,b,c)
	return a+(b-a)*c
end
function balls(c1,c2,alBRUH)
	local al = .05
	local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
	local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
	for i,v in pairs(com1) do
		com1[i] = brup(v,com2[i],al)
	end
	return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
end
-- Some dumb stuff --

-- Change Modes --
local rdmsong = 0
local AttackType = "Shoot"
function ChangeMode(MODE)
	Mode = MODE
	if Mode == "Amalgam" then
		MusicReal.SoundId = "rbxassetid://361511879"
	end
	if Mode == "None" then
		MusicReal.SoundId = "rbxassetid://3979209289"
	end
	if Mode == "Fast" then
		MusicReal.SoundId = "rbxassetid://2920078671"
	end
	if Mode == "Zeke" then
		MusicReal.SoundId = "rbxassetid://2695321137"
	end
	if Mode == "Lord" then
		MusicReal.SoundId = "rbxassetid://6049110238"
	end
	if Mode == "Trussing" then
		MusicReal.SoundId = "rbxassetid://7576995029"
	end
	if Mode == "NDaD" then
		MusicReal.SoundId = "rbxassetid://2702926518"

		AttackType = "Sword"
		athp1.Position = Vector3.new(100, 100, 100) -- GunPos
		athp7.Position = Vector3.new(0, 1.95, 1) --SwordPos
	end
	if Mode == "|" then
		rdmsong = math.random(1,2)
		if rdmsong == 1 then
			MusicReal.SoundId = "rbxassetid://5707455397"
		else
			MusicReal.SoundId = "rbxassetid://7888676755"
		end

		AttackType = "Shoot"
		athp1.Position = Vector3.new(0, 0, .5)
		athp7.Position = Vector3.new(100, 100, 100)
	end
	if Mode == "IDK" then
		MusicReal.SoundId = "rbxassetid://803373182"
	end
	if Mode == "Banisher2" then
		MusicReal.SoundId = "rbxassetid://213723476"
	end
	if Mode == "LC" then
		MusicReal.SoundId = "rbxassetid://3247404955"
	end
	if Mode == "MLC" then
		MusicReal.SoundId = "rbxassetid://6768783121"
	end
	if Mode == "Kick" then
		MusicReal.SoundId = "rbxassetid://146682341"
	end
	if Mode == "PetFroge" then
		MusicReal.SoundId = "rbxassetid://3080683313"
	end
	if Mode == "Porple" then
		MusicReal.SoundId = "rbxassetid://5686179869"
	end
	if Mode == "Death" then
		MusicReal.SoundId = "rbxassetid://1426355953"
	end
	if Mode == "Cyber" then
		MusicReal.SoundId = "rbxassetid://170282324"
	end
	if Mode == "BigBan" then
		MusicReal.SoundId = "rbxassetid://2385953834"
	end
	if Mode == "RainbowHell" then
		MusicReal.SoundId = "rbxassetid://1899417820"
	end
	if Mode == "Zero" then
		MusicReal.SoundId = "rbxassetid://1342075752"
	end
	if Mode == "GodCat" then
		MusicReal.SoundId = "rbxassetid://1416035124"
	end
	if Mode == "HLC - as" then
		MusicReal.SoundId = "rbxassetid://1551788627"
	end
	if Mode == "HLC - ho" then
		MusicReal.SoundId = "rbxassetid://5034449870"
	end
	if Mode == "HLC - uw" then
		MusicReal.SoundId = "rbxassetid://5703266925"
	end
	if Mode == "HLC - rars" then
		MusicReal.SoundId = "rbxassetid://493647101"
	end
	if Mode == "Blood" then
		MusicReal.SoundId = "rbxassetid://3250172020"
	end
	MusicReal.TimePosition = 0
end
-- Change Modes --

-- welds? lol? --

local diesfromcringe = {Defaults = {RightShoulder = {C0 = CFrame.new(-.5,0,0)*CFrame.Angles(0,math.rad(90),0)}},{RootJoint = {C0 = CFrame.new(),C1 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)}}}

local necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local angles = CFrame.Angles
local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
-- welds? lol? --
-- Cool local functions ig lol --
local function randomstring()
	local part1 = math.random()/tick()
	part1 = tostring(part1)
	part1 = string.gsub(part1, "-", "")
	return part1
end

function QuaternionToCFrameX2(px, py, pz, x, y, z, w) 
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end

function QuaternionFromCFrameX2(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end

function seriouslybro(a, b, t) 
	local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
	local startInterp, finishInterp; 
	if cosTheta >= 0.0001 then 
		if (1 - cosTheta) > 0.0001 then 
			local theta = math.acos(cosTheta) 
			local invSinTheta = 1/math.sin(theta) 
			startInterp = math.sin((1-t)*theta)*invSinTheta 
			finishInterp = math.sin(t*theta)*invSinTheta  
		else 
			startInterp = 1-t 
			finishInterp = t 
		end 
	else 
		if (1+cosTheta) > 0.0001 then 
			local theta = math.acos(-cosTheta) 
			local invSinTheta = 1/math.sin(theta) 
			startInterp = math.sin((t-1)*theta)*invSinTheta 
			finishInterp = math.sin(t*theta)*invSinTheta 
		else 
			startInterp = t-1 
			finishInterp = t 
		end 
	end 
	return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

spicy = {
	OG = function(a,b,t) 
		local qa = {QuaternionFromCFrameX2(a)}
		local qb = {QuaternionFromCFrameX2(b)} 
		local ax, ay, az = a.x, a.y, a.z 
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1-t
		return QuaternionToCFrameX2(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,seriouslybro(qa, qb, t)) 
	end,
}

local Serv = setmetatable({},{__call = function(_,classname)
	return game:FindFirstChildOfClass(classname)
end,})
local function CamShake(Length,Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1*Intensity
		local rotM = 0.01*Intensity
		for i = 0, Length, 0.1 do
			Serv('RunService').RenderStepped:wait()
			intensity = intensity - 0.05*Intensity/Length
			rotM = rotM - 0.0005*Intensity/Length
			Humanoid.CameraOffset = Vector3.new(math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity)))
			Serv("Workspace").CurrentCamera.CFrame = Serv("Workspace").CurrentCamera.CFrame * CFrame.new(math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity))) * CFrame.fromEulerAnglesXYZ(math.rad(math.random(-intensity, intensity)) * rotM, math.rad(math.random(-intensity, intensity)) * rotM, math.rad(math.random(-intensity, intensity)) * rotM)
		end
		Humanoid.CameraOffset = Vector3.new(0, 0, 0)
	end))
end

-- Cool local functions ig lol --
-- Smooth Loop --
local lIT = false
local woahahuman = game.Players.LocalPlayer.Character.Humanoid
local neonpart = Instance.new("Part",HiddenPlace)
neonpart.Anchored = true
neonpart.CanCollide = false

local function CreateSelection(Name,Parent,Adornee,Transparency,LineThickness,Color)
	local NewSelection = Instance.new("SelectionBox",Parent)
	NewSelection.Adornee = Adornee
	NewSelection.Transparency = Transparency
	NewSelection.LineThickness = LineThickness
	NewSelection.Color3 = Color
end

local VisibleFling = Instance.new("SelectionBox")
VisibleFling.Parent = Character
VisibleFling.Transparency = .5
VisibleFling.LineThickness = 0.1
VisibleFling.Color3 = Color3.new(0.584314, 0, 1)
VisibleFling.Adornee = game.Players.LocalPlayer.Character.HumanoidRootPart


if ShowReanim == true then
	local HeadSelection = CreateSelection("HeadSelection",Head,Head,.5,.1,neonpart.Color)
	local TorsoSelection = CreateSelection("TorsoSelection",Torso,Torso,.5,.1,neonpart.Color)
	local LASelection = CreateSelection("LASelection",LeftArm,LeftArm,.5,.1,neonpart.Color)
	local RASelection = CreateSelection("RASelection",RightArm,RightArm,.5,.1,neonpart.Color)
	local LLSelection = CreateSelection("LLSelection",LeftLeg,LeftLeg,.5,.1,neonpart.Color)
	local RLSelection = CreateSelection("RLSelection",RightLeg,RightLeg,.5,.1,neonpart.Color)
end

local ischattinglol = false
local eee = MusicReal
local ChMove = false
game:GetService("RunService").RenderStepped:Connect(function(fps)

	-- Stuff to always do --
	local Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
	sine = sine +1
	Sine = sine
	SINE = sine

	if doe < 360 then
		doe = doe + 2
	else
		doe = 0
	end

	Humanoid.WalkSpeed = sensitivity
	Humanoid.HipHeight = HipVal

	local MusicLoudness = MusicReal.PlaybackLoudness * 0.2
	woahahuman.Health = MusicLoudness

	local FPS = math.floor(1/fps)
	FPSCounter.FPS.Display.Text = "〔"..FPS.."〕"

	neonpart.Color = BrickColor.Random().Color

	FPSCounter.LeaveGame.TextColor3 = neonpart.Color
	VisibleFling.Color3 = neonpart.Color

	TextHolder.Text = Mode

	TextHolder.TextColor3 = neonpart.Color

	workspace.FallenPartsDestroyHeight = -500

	if lIT == false then
		HumanRoot.CanCollide = false
		HumanRoot.Position = CloneChar.Torso.Position
		ThrusterThing.Location = CloneChar.HumanoidRootPart.Position
	else
		HumanRoot.CanCollide = true
	end

	if Torsovelocity >= sensitivity - sensitivity + 1 then
		ChMove = true
	elseif Torsovelocity < sensitivity - sensitivity + 1 then	
		ChMove = false
	end

	local WALKSPEEDVALUE = 10 / (Humanoid.WalkSpeed / 16)
	local SIZE = 1
	local S = 1

	for i,v in pairs(Character:GetChildren()) do
		if v:IsA("BasePart") and v.Anchored == false and v.Position.Y < (workspace.FallenPartsDestroyHeight + 50) then
			local flot = Instance.new("BodyPosition")
			local spen = Instance.new("BodyGyro")
			local hu = math.huge
			flot.MaxForce = Vector3.new(hu,hu,hu)
			spen.MaxTorque = Vector3.new(hu,hu,hu)
			local spown = nil
			for o,b in pairs(workspace:GetDescendants()) do
				if not b:IsDescendantOf(Character) and b:IsA("SpawnLocation") then
					spown = b
				end
			end
			if spown then
				RootPart.CFrame = CFrame.new(spown.Position.X,spown.Position.Y+(spown.Size.Y/2)+6+Humanoid.HipHeight,spown.Position.Z)
			else
				local base = workspace:FindFirstChild("Base")
				if not base then
					base = workspace:FindFirstChild("Baseplate")
				end
				if base then
					RootPart.CFrame = CFrame.new(math.clamp(RootPart.Position.X,(-base.Size.X/2)+5,(base.Size.X/2)-5),base.Position.Y+(base.Size.Y/2)+6+Humanoid.HipHeight,math.clamp(RootPart.Position.Z,(-base.Size.X/2)+5,(base.Size.X/2)-5))
				else
					RootPart.CFrame = CFrame.new(math.clamp(RootPart.Position.X,-100,100),100,math.clamp(RootPart.Position.Z,-100,100))
				end
			end
			flot.Position = RootPart.Position
			flot.Parent = RootPart
			spen.CFrame = RootPart.CFrame
			spen.Parent = RootPart
			game:GetService("Debris"):AddItem(flot,1)
			game:GetService("Debris"):AddItem(spen,1)
		end
	end
	-- Stuff to always do --

	RWingWld.C0 = Clerp(RWingWld.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(sine/15)),0),.25)
	LWingWld.C0 = Clerp(LWingWld.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(sine/15)),0),.25)

	-- Animation for modes --
	if Mode == "None" then -- I made the animation
		eeevol = 5
		HipVal = 3
		eeepitch = 1
		change = 1
		sensitivity = 25

		atho2.Rotation = Vector3.new(0, 0, Sine + 9)
		--WACKYEFFECT({Time = 1, EffectType = "Block", Size =VT(1+eee.PlaybackLoudness/500,1+eee.PlaybackLoudness/500,1+eee.PlaybackLoudness/500), Size2 = VT(1+eee.PlaybackLoudness/300,1+eee.PlaybackLoudness/300,1+eee.PlaybackLoudness/300), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0+9*math.sin(sine/35),0+2*math.sin(sine/75),0+9*math.cos(sine/35))*CFrame.Angles(math.rad(-sine*.5),math.rad(-sine*1),math.rad(-sine*1.5)), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = GUN.NeonParts.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if attack == false then
			if Torsovelocity < sensitivity - sensitivity + 1 then -- Hmm
				Anim = "Idle"
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-120+5*math.cos(sine/20)),math.rad(0),math.rad(0)),1/2)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,0 - .5 * math.sin(sine/20))*CFrame.Angles(math.rad(-25-5*math.cos(sine/20)),0,0),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(30-1*math.cos(sine/20)),math.rad(0),math.rad(0)),0.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20 + 8.5 * math.cos(sine/20)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/20))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 38 * math.cos(sine/20)),math.rad(80),math.rad(0))*CFrame.Angles(0,0,math.rad(15 - 25 * math.cos(sine/20))),0.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0 + 38 * math.cos(sine/20)),math.rad(-80),math.rad(0))*CFrame.Angles(0,0,math.rad(-15 + 25 * math.cos(sine/20))),0.7/3)
			elseif Torsovelocity >= sensitivity - sensitivity + 1 then
				Anim = "Walk"
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,0 - .5 * math.sin(sine/20))*CFrame.Angles(math.rad(40-1*math.cos(sine/20)),0,0),.25)
				Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(sine/19)))*LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-50 + 35 * math.cos(sine/20)),math.rad(80),math.rad(0))*CFrame.Angles(0,0,math.rad(15 - 25 * math.cos(sine/20))),0.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-35 + 35 * math.cos(sine/20)),math.rad(-80),math.rad(0))*CFrame.Angles(0,0,math.rad(-15 + 25 * math.cos(sine/20))),0.7/3)
			end
		end
	end
	if Mode == "Amalgam" then
		eeepitch = 1
		eeevol = 5
		HipVal = 0
		change = 1
		sensitivity = 16

		atho2.Rotation = Vector3.new(0, 0, -Sine + 3)

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if attack == false then
			if Torsovelocity < sensitivity - sensitivity + 1 then
				Anim = "Idle"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,.05*math.cos(sine/12))*CFrame.Angles(math.rad(15),0,0),1 / 3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.Angles(math.rad(-15-3*math.cos(sine/12)),math.rad(5-5*math.sin(sine/12)),0),1 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5+0.1*math.cos(sine/12),0)*CFrame.Angles(math.rad(-53.75+1.75*math.cos(sine/12)),0,math.rad(5))* RIGHTSHOULDERC0,1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5+.1*math.sin(sine/12),0)*CFrame.Angles(math.rad(15),0,math.rad(-5+5*math.cos(sine/12)))* LEFTSHOULDERC0,1 / 3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1-.06*math.cos(sine/12),-.01)*CFrame.Angles(math.rad(10),math.rad(80),math.rad(0)),1 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1-.06*math.cos(sine/12),-.01)*CFrame.Angles(math.rad(20),math.rad(-80),math.rad(0)),1 / 3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),0,0),.25)
			elseif Torsovelocity >= sensitivity - sensitivity + 1 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,.125*math.sin(sine/12),0)*CFrame.Angles(math.rad(10-5*math.cos(sine/12)),math.rad(-10*math.cos(sine/12)),math.rad(-5*math.cos(sine/12))),.25)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.Angles(math.rad(10-5*math.cos(sine/12)),math.rad(10*math.cos(sine/12)),math.rad(5*math.cos(sine/12))),.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5+.2*math.sin(sine/12),-.25)*CFrame.Angles(math.rad(165-15*math.cos(sine/12)),math.rad(-10+5*math.sin(sine/12)),math.rad(10))* RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5-.15*math.cos(sine/12),.5*math.sin(sine/12))*CFrame.Angles(math.rad(-30*math.sin(sine/12)),math.rad(5*math.cos(sine/12)),0)* LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.9-.2*math.cos(sine/12),.5*math.sin(sine/12))*CFrame.Angles(math.rad(-10-40*math.sin(sine/12)),math.rad(90+5*math.cos(sine/12)),math.rad(2.5*math.cos(sine/12))),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-.9+.2*math.cos(sine/12),-.5*math.sin(sine/12))*CFrame.Angles(math.rad(-10+40*math.sin(sine/12)),math.rad(-90+5*math.cos(sine/12)),math.rad(2.5*math.cos(sine/12))),.25)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			end
		end
	end
	if Mode == "Fast" then
		eeepitch = 1
		eeevol = 5
		HipVal = 0
		change = 1
		sensitivity = 125

		atho2.Rotation = Vector3.new(0, 0, Sine + 19)

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if attack == false then
			if Torsovelocity < sensitivity - sensitivity + 1 then
				Anim = "Idle"
				HipVal = .1
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(-sine*6),math.rad(0),math.rad(0)),.25)
				Neck.C0 = Clerp(Neck.C0,NECKC0,.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(-75*math.sin(sine/5)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(75*math.sin(sine/5)),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(75*math.sin(sine/5)),math.rad(90),math.rad(0)),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(-75*math.sin(sine/5)),math.rad(-90),math.rad(0)),.25)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
			elseif Torsovelocity >= sensitivity - sensitivity + 1 then
				Anim = "Walk"
				HipVal = 0
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),.25/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),.25/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.6,.5) * CFrame.Angles(math.rad(-135),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,.75/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.6,.5) * CFrame.Angles(math.rad(-135),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,.75/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(180+-sine*sensitivity),math.rad(90),math.rad(0)),1)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(-sine*sensitivity),math.rad(-90),math.rad(0)),1)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
		end
	end
	if Mode == "Zeke" then
		eeevol = 5
		HipVal = 0
		eeepitch = 1
		change = 1
		sensitivity = 35

		atho2.Rotation = Vector3.new(0, 0, 0)

		if attack == false then
			if Torsovelocity < sensitivity - sensitivity + 1 then
				Anim = "Idle"
				if attack == false then
					RootJoint.C0 = obunga(RootJoint.C0,ROOTC0 * CF(0, 0, -0.03 + 0.05 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 5)-- -35
					Neck.C0 = obunga(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(Sine / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / 5)
					if math.random(1,5) == 1 then
						Neck.C0 = obunga(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(Sine / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / 3)	
					end
					RightShoulder.C0 = obunga(RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*diesfromcringe.Defaults.RightShoulder.C0,.25)
					LeftShoulder.C0 = obunga(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(Sine / 12)), RAD(-12 - 7.5 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / 5)
					RightHip.C0 = obunga(RightHip.C0, CF(1, -1 - 0.05 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(95), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / 5)
					LeftHip.C0 = obunga(LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-12), RAD(0), RAD(0)), 1 / 5)
					gunweld.C0 = Clerp(gunweld.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
				end
			elseif Torsovelocity >= sensitivity - sensitivity + 1 then
				Anim = "Walk"
				if attack == false then
					RootJoint.C0 = obunga(RootJoint.C0, ROOTC0 * CF(0* 1, 0* 1, -0.175 + 0.025 * COS(Sine / 3.5) + -SIN(Sine / 3.5) / 7* 1) * ANGLES(RAD(26 - 4.5 * COS(Sine / 3.5)), RAD(0) - Character.Torso.RotVelocity.Y / 75, RAD(15 * COS(Sine / 7))), 0.15)
					Neck.C0 = obunga(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(Sine / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / 3)
					if math.random(1,5) == 1 then
						Neck.C0 = obunga(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(Sine / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / 3)	
					end
					RightHip.C0 = obunga(RightHip.C0, CF(1* 1, -0.925 - 0.5 * COS(Sine / 7) / 2* 1, 0.7 * COS(Sine / 7) / 2* 1) * ANGLES(RAD(-15 - 55 * COS(Sine / 7)) - RightLeg.RotVelocity.Y / 75 + -SIN(Sine / 7) / 2.5, RAD(90 - 0.1 * COS(Sine / 7)), RAD(0)) * ANGLES(RAD(0 + 0.1 * COS(Sine / 7)), RAD(0), RAD(0)), 0.3)
					LeftHip.C0 = obunga(LeftHip.C0, CF(-1* 1, -0.925 + 0.5 * COS(Sine / 7) / 2* 1, -0.7 * COS(Sine / 7) / 2* 1) * ANGLES(RAD(-15 + 55 * COS(Sine / 7)) + LeftLeg.RotVelocity.Y / 75 + SIN(Sine / 7) / 2.5, RAD(-90 - 0.1 * COS(Sine / 7)), RAD(0)) * ANGLES(RAD(0 - 0.1 * COS(Sine / 7)), RAD(0), RAD(0)), 0.3)
					RightShoulder.C0 = obunga(RightShoulder.C0,CFrame.new(1.5,.5+.2*math.sin(Sine/12),-.25)*CFrame.Angles(math.rad(165-15*math.cos(Sine/12)),math.rad(-10+5*math.sin(Sine/12)),math.rad(10))*diesfromcringe.Defaults.RightShoulder.C0,.25)
					LeftShoulder.C0 = obunga(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(Sine / 30)* 1, -0.34 * COS(Sine / 7* 1)) * ANGLES(RAD(-110)  * COS(Sine / 7) , RAD(-90) ,	RAD(-13) + LeftArm.RotVelocity.Y / 75), 0.15)
					gunweld.C0 = Clerp(gunweld.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
				end
			end
		end
	end
	if Mode == "Lord" then
		HipVal = 3
		eeepitch = 1
		change = 1
		sensitivity = 25

		atho2.Rotation = Vector3.new(0, 0, -Sine + 3)

		eeevol = 5
		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if attack == false then
			if Torsovelocity < sensitivity - sensitivity + 1 then
				Anim = "Idle"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20),math.rad(10*math.cos(sine/100)),math.rad(0)),1)
				if math.random(1,60) == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.cos(sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
				end
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif Torsovelocity >= sensitivity - sensitivity + 1 then
				Anim = "Walk"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
		end
	end
	if Mode == "Trussing" then
		HipVal = 2
		eeepitch = 1
		change = 1
		sensitivity = 25

		atho2.Rotation = Vector3.new(0, 0, -Sine)

		eeevol = 5
		Animation_Speed = 3
		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if attack == false then
			if Torsovelocity < sensitivity - sensitivity + 1 then
				Anim = "Idle"
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 6.5 * SIN(sine / 15)), RAD(10 * SIN(sine/32)), RAD(-10 + 5.5 * SIN(sine /15))), 3 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0 - 5.5 * SIN(sine/12)), RAD(5 * SIN(sine /12)), RAD(22 + 4.4 * SIN(sine /12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0- 5.5 * SIN(sine /12)), RAD(5 * SIN(sine /12)), RAD(-22 + 4.4 * SIN(sine/12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 1 * COS(sine / 39)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(80+10* SIN(sine / 78)), RAD(0)) * ANGLES(RAD(-3+1* SIN(sine / 58)), RAD(0), RAD(2.5+8 * SIN(sine / 43))), 0.8 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(0), RAD(-80-10* SIN(sine / 81)), RAD(0)) * ANGLES(RAD(-3+1* SIN(sine / 63)), RAD(0), RAD(0+15 * SIN(sine / 49))), 0.8 / Animation_Speed)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif Torsovelocity >= sensitivity - sensitivity + 1 then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.5 * COS(sine / 24)) * ANGLES(RAD(24), RAD(-5 * SIN(sine / 24)), RAD(0)), 0.4 / Animation_Speed*3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-24), RAD(5 * SIN(sine / 24)), RAD(MRANDOM(-5.5,5.5))), 0.2)			
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.15 * COS(sine / 24), 0) * ANGLES(RAD(-45), RAD(0), RAD(14 + 6.5* SIN(sine / 24)))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.15 * COS(sine / 24), 0) * ANGLES(RAD(-45), RAD(0), RAD(-14 - 6.5 * SIN(sine / 24))) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(sine / 24), 0) * ANGLES(RAD(-25), RAD(78), RAD(0)) * ANGLES(RAD(-5 * SIN(sine / 24)), RAD(0), RAD(5)), 0.4 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.3 - 0.1 * COS(sine / 24), -0.5) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(-5 * SIN(sine / 24)), RAD(0), RAD(5)), 0.4 / Animation_Speed)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
		end
	end
	if Mode == "NDaD" then
		HipVal = 0
		change = 1
		sensitivity = 16

		atho2.Rotation = Vector3.new(0, 0, Sine + 10)

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if attack == false then
			if RootPart.Velocity.y > 1 then 
				Anim = "Jump"
				if true then
					gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.36) * CFrame.Angles(math.rad(-3),math.rad(0),math.rad(0)),1 / 3)
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(50),math.rad(0),math.rad(25 + 10 * math.cos(sine / 12))) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(50),math.rad(0),math.rad(-25 - 10 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.4,-0.6) * CFrame.Angles(math.rad(1),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-85),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
				end
			elseif RootPart.Velocity.y < -1 then 
				Anim = "Fall"
				if not attack then
					gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.36) * CFrame.Angles(math.rad(-34),math.rad(0),math.rad(0)),1 / 3)
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(35 - 4 * math.cos(sine / 6)),math.rad(0),math.rad(45 + 10 * math.cos(sine / 12))) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(35 - 4 * math.cos(sine / 6)),math.rad(0),math.rad(-45 - 10 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.3,-0.7) * CFrame.Angles(math.rad(-25 + 5 * math.sin(sine / 12)),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-0.8,-0.3) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
				end
			elseif Torsovelocity < sensitivity - sensitivity + 1 then
				Anim = "Idle"
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.36) * CFrame.Angles(math.rad(-3),math.rad(0),math.rad(0)),1 / 3)

				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 3* COS(sine / 55)), RAD(0), RAD(0)), 0.8 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(75), RAD(0), RAD(47)) * RIGHTSHOULDERC0, 0.8 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-16)) * LEFTSHOULDERC0, 0.8 / 3)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+0.2* COS(sine / 55)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / 3)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1-0.2* COS(sine / 55), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-0.2* COS(sine / 55), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / 3)
			elseif Torsovelocity >= sensitivity - sensitivity + 1 then
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.36) * CFrame.Angles(math.rad(-3),math.rad(0),math.rad(0)),1 / 3)

				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 2* SIN(sine / 6)), RAD(0), RAD(0-1*COS(sine / 12))), 0.8 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(75+5*math.sin(sine / 6)), RAD(0), RAD(47)) * RIGHTSHOULDERC0, 0.8 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0+25* SIN(sine / 12)), RAD(0), RAD(-12-5*COS(sine / 6))) * LEFTSHOULDERC0, 0.8 / 3)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1+0.1* COS(sine / 6)) * ANGLES(RAD(5-1*math.cos(sine/12)), RAD(0+1*COS(sine / 12)), RAD(0-2*SIN(sine / 12))), 0.8 / 3)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0-0.07*SIN(sine/12)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-5), RAD(-5 + 45 * SIN(sine / 12))), 0.8 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0+0.07*SIN(sine/12)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(5), RAD(5 + 45 * SIN(sine / 12))), 0.8 / 3)
			end
		end
	end
	if Mode == "|" then
		HipVal = 0
		sensitivity = 16

		atho2.Rotation = Vector3.new(0, 0, -Sine + 10)

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if attack == false then
			if RootPart.Velocity.y > 1 then 
				Anim = "Jump"
				RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
				Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),1 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(50),math.rad(0),math.rad(25 + 10 * math.cos(sine / 12))) * rscp,1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(50),math.rad(0),math.rad(-25 - 10 * math.cos(sine / 12))) * lscp,1 / 3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.4,-0.6) * CFrame.Angles(math.rad(1),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-85),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
			elseif RootPart.Velocity.y < -1 then 
				Anim = "Fall"
				RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
				Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(35 - 4 * math.cos(sine / 6)),math.rad(0),math.rad(45 + 10 * math.cos(sine / 12))) * rscp,1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(35 - 4 * math.cos(sine / 6)),math.rad(0),math.rad(-45 - 10 * math.cos(sine / 12))) * lscp,1 / 3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.3,-0.7) * CFrame.Angles(math.rad(-25 + 5 * math.sin(sine / 12)),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-0.8,-0.3) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
			elseif Torsovelocity < sensitivity - sensitivity + 1 then
				Anim = "Idle"
				if attack == false then
					if math.random(1,50)==1 then
						LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5+math.random(-5,5),0.5+math.random(-5,5),0+math.random(-5,5)) * CFrame.Angles(math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999))) * LEFTSHOULDERC0,0.7/3)
					end
					if math.random(1,50)==1 then
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0+math.random(-5,5),0+math.random(-5,5),0+math.random(-5,5)) * ANGLES(RAD(math.random(-99999,9999)), RAD(math.random(-99999,9999)), RAD(math.random(-99999,9999))), 0.2)			
					end
					if math.random(1,50)==1 then
						RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5+math.random(-5,5),0.5+math.random(-5,5),0+math.random(-5,5)) * CFrame.Angles(math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999))) * RIGHTSHOULDERC0,0.7/3)
					end
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,0+.1*COS(sine / 12))*ANGLES(RAD(0),RAD(0),RAD(0)), 0.8 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 6.5 * SIN(sine / 15)), RAD(10 * SIN(sine/32)), RAD(-10 + 5.5 * SIN(sine /15))), 0.8 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0 - 5.5 * SIN(sine/12)), RAD(5 * SIN(sine /12)), RAD(22 + 4.4 * SIN(sine /12))) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0- 5.5 * SIN(sine /12)), RAD(5 * SIN(sine /12)), RAD(-22 + 4.4 * SIN(sine/12))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.1*COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(80-5*math.sin(sine/12)), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-.1*COS(sine  / 12), -0.01) * ANGLES(RAD(0), RAD(-80 + 5*math.sin(sine/12)), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
			elseif Torsovelocity >= sensitivity - sensitivity + 1 then
				Anim = "Walk"
				if attack == false then
					if math.random(1,50)==1 then
						LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5+math.random(-5,5),0.5+math.random(-5,5),0+math.random(-5,5)) * CFrame.Angles(math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999))) * LEFTSHOULDERC0,0.7/3)
					end
					if math.random(1,50)==1 then
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0+math.random(-5,5),0+math.random(-5,5),0+math.random(-5,5)) * ANGLES(RAD(math.random(-99999,9999)), RAD(math.random(-99999,9999)), RAD(math.random(-99999,9999))), 0.2)			
					end
					if math.random(1,50)==1 then
						RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5+math.random(-5,5),0.5+math.random(-5,5),0+math.random(-5,5)) * CFrame.Angles(math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999))) * RIGHTSHOULDERC0,0.7/3)
					end
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 2* SIN(sine / 6)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0-25* SIN(sine / 12)), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0+25* SIN(sine / 12)), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1+0.1* COS(sine / 6)) * ANGLES(RAD(5-1*math.cos(sine/12)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0-0.07*SIN(sine/12)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-5), RAD(-5 + 45 * SIN(sine / 12))), 0.8 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0+0.07*SIN(sine/12)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(5), RAD(5 + 45 * SIN(sine / 12))), 0.8 / Animation_Speed)
					gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
			end
		end
	end
	if Mode == "IDK" then
		HipVal = 3
		change = 1
		sensitivity = 40

		atho2.Rotation = Vector3.new(0, 0, Sine + 10)

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if attack == false then
			if Torsovelocity < sensitivity - sensitivity + 1 then
				Anim = "Idle"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 - .5 * math.sin(sine/30)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20-5*math.cos(sine/30)),0,0),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.cos(sine/30))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.cos(sine/30))),1/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.cos(sine/30))),1/3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif Torsovelocity >= sensitivity - sensitivity + 1 then
				Anim = "Walk"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 - .5 * math.sin(sine/30)) * CFrame.Angles(math.rad(28.947),math.rad(0),math.rad(0)),0.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(-8),math.rad(0),math.rad(0)),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20),math.rad(0),math.rad(-10-10*math.cos(sine/30))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-30),math.rad(80),math.rad(10+10*math.cos(sine/30))),1/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(-80),math.rad(-10-10*math.cos(sine/30))),1/3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
		end
	end
	if Mode == "Banisher2" then
		HipVal = 3
		change = 2 / Animation_Speed
		sensitivity = 40

		atho2.Rotation = Vector3.new(0, 0, -Sine + 10)

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if attack == false then
			if Torsovelocity < sensitivity - sensitivity + 1 then
				Anim = "Idle"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 1 * SIN(sine / 26)) * ANGLES(RAD(-25 - 2.5*COS(sine/26)), RAD(0), RAD(0)), 1 / 3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 - 1 * COS(sine / 26)), RAD(0), RAD(0)), 1 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-12 + 4.10 * COS(sine / 26))) * LEFTSHOULDERC0, 1 / 3)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(sine / 12), -0.5) * ANGLES(RAD(-5 - 2.5 * COS(sine / 26)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(sine / 12), -0.01) * ANGLES(RAD(5 - 2.5 * SIN(sine / 26)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)	
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif Torsovelocity >= sensitivity - sensitivity + 1 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 1 * SIN(sine / 26)) * ANGLES(RAD(50 - 2.5*SIN(sine/26)), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(sine / 47))), 1 / 3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-50 - 2.5 * SIN(sine / 26)), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y)), 1 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.3, 0) * ANGLES(RAD(-15), RAD(0), RAD(12 - 4.10 * SIN(sine / 26))) * RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.3, 0) * ANGLES(RAD(-15), RAD(0), RAD(-12 + 4.10 * SIN(sine / 26))) * LEFTSHOULDERC0, 1 / 3)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -.4 - 0.02 * SIN(sine / 26), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(sine / 26)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(sine / 26), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(sine / 26)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)	
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)), 1 / 3)
			end
		end
	end
	if Mode == "LC" then

		HipVal = 2
		sensitivity = 25

		atho2.Rotation = Vector3.new(0, 0, -Sine + 10)

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		if attack == false then
			if Torsovelocity < sensitivity - sensitivity + 1 then
				Anim = "Idle"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)),0.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif Torsovelocity >= sensitivity - sensitivity + 1 then
				Anim = "Walk"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(40),math.rad(0),math.rad(0)),0.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),0.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,0.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-5 - 2 * math.cos(sine/19))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
		end
	end
	if Mode == "MLC" then

		atho2.Rotation = Vector3.new(0, 0, Sine + 10)

		HipVal = 1
		change = 1
		sensitivity = 25
		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if attack == false then
			if ChMove == false then -- Hmm
				Anim = "Idle"
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,0 - .5 * math.sin(sine/20))*CFrame.Angles(math.rad(-30.9-5*math.cos(sine/20)),0,0),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(35-2*math.cos(sine/20)),math.rad(0),math.rad(0)),0.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(130), math.rad(0), math.rad(15))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20 + 8.5 * math.cos(sine/20)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/20))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(0 + 38 * math.cos(sine/20)),math.rad(80),math.rad(0))*CFrame.Angles(0,0,math.rad(15 - 25 * math.cos(sine/20))),0.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-30.9 + 38 * math.cos(sine/20)),math.rad(-80),math.rad(0))*CFrame.Angles(0,0,math.rad(-15 + 25 * math.cos(sine/20))),0.7/3)
			elseif ChMove == true then
				Anim = "Walk"
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,0 - .5 * math.sin(sine/20))*CFrame.Angles(math.rad(40-1*math.cos(sine/20)),0,0),.25)
				Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(sine/19)))*LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-50 + 35 * math.cos(sine/20)),math.rad(80),math.rad(0))*CFrame.Angles(0,0,math.rad(15 - 25 * math.cos(sine/20))),0.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-35 + 35 * math.cos(sine/20)),math.rad(-80),math.rad(0))*CFrame.Angles(0,0,math.rad(-15 + 25 * math.cos(sine/20))),0.7/3)
			end
		end
	end
	if Mode == "Kick" then

		atho2.Rotation = Vector3.new(0, 0, -Sine + 10)

		HipVal = 1
		change = 1
		sensitivity = 25
		if attack == false then
			if ChMove == false then
				local snap = math.random(1,5)
				if snap == 1 then
					Neck.C0 = Clerp(Neck.C0,necko*angles(math.rad(25 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),0.6)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(sine / 12)) * ANGLES(RAD(4 + 2.5 * SIN(sine / 12)), RAD(0), RAD(25)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(sine / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.35 + 0.15 * COS(sine / 12), 0) * ANGLES(RAD(110), RAD(-15 - 2.5 * SIN(sine / 12)), RAD(35 + 7.5 * SIN(sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(5), RAD(0), RAD(-15 + -10 * SIN(sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(sine / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(sine / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
			elseif ChMove == true  then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(sine / 12)) * ANGLES(RAD(25 + 2.5 * SIN(sine / 12)), RAD(0), RAD(25)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(sine / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.35 + 0.15 * COS(sine / 12), 0) * ANGLES(RAD(110), RAD(-15 - 2.5 * SIN(sine / 12)), RAD(35 + 7.5 * SIN(sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25-2.5 * SIN(sine / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(sine / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
			end
		end
	end
	if Mode == "PetFroge" then

		atho2.Rotation = Vector3.new(0, 0, Sine + 10)

		HipVal = 0
		change = 1
		sensitivity = 25

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		if attack == false then
			if ChMove == false then
				Anim = "Idle"
				RightHip.C0=Clerp(RightHip.C0,CFrame.new(1,0.2 - 0.1 * math.cos(sine / 20),-0.3)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))*CFrame.Angles(math.rad(3),math.rad(15 - 2 * math.cos(sine / 56)),math.rad(50 - 2 * math.cos(sine / 32))),.1)
				LeftHip.C0=Clerp(LeftHip.C0,CFrame.new(-1,-1 - 0.1 * math.cos(sine / 20),0)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))*CFrame.Angles(math.rad(3),math.rad(-1 - 2 * math.cos(sine / 56)),math.rad(20 + 2 * math.cos(sine / 32))),.1)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,-0 + 0.03 * math.cos(sine / 32),-1.2 + 0.1 * math.cos(sine / 20))*CFrame.Angles(math.rad(45 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-30 + 2 * math.cos(sine / 56))),.1)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.Angles(math.rad(23 - 2 * math.cos(sine / 37)),math.rad(0 + 5 * math.cos(sine / 43) - 5 * math.cos(sine / 0.25)),math.rad(22 - 2 * math.cos(sine / 56))),.1)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*CFrame.Angles(math.rad(5 + 3 * math.cos(sine / 43)),math.rad(-14 - 5 * math.cos(sine / 52)),math.rad(63 + 9 * math.cos(sine / 45))),.1)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.35,1 + 0.025 * math.cos(sine / 45),-0.2)*CFrame.Angles(math.rad(148 - 2 * math.cos(sine / 51)),math.rad(0 - 4 * math.cos(sine / 64)),math.rad(22 - 2 * math.cos(sine / 45))),.1)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif ChMove == true then
				Anim = "Walk"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 - 0.15 * math.cos(sine / 47), -0.5, 0.5 + 0.1 * math.cos(sine / 28)) * CFrame.Angles(math.rad(70), math.rad(0 - RootPart.RotVelocity.Y), math.rad(0 - RootPart.RotVelocity.Y * 4.5 + 3 * math.cos(sine / 47))), .2 / 3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(-17 - 5 * math.cos(sine / 52)), math.rad(0 - 3 * math.cos(sine / 37)), math.rad(0 + 2 * math.cos(sine / 78))), .2 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5 + 0.05 * math.cos(sine / 28), 0) * CFrame.Angles(math.rad(-8 - 4 * math.cos(sine / 59)), math.rad(-20 + 7 * math.cos(sine / 62)), math.rad(20 + 5 * math.cos(sine / 50)))* RIGHTSHOULDERC0, .2 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5 + 0.1 * math.cos(sine / 28), 0) * CFrame.Angles(math.rad(-8 - 3 * math.cos(sine / 55)), math.rad(20 + 8 * math.cos(sine / 67)), math.rad(-20 - 4 * math.cos(sine / 29))) * LEFTSHOULDERC0, .2 / 3)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1 , -0.5, -0.6) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(1.5), math.rad(0), math.rad(-20 - 5 * math.cos(sine / 34))), .2 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(1), math.rad(0), math.rad(20 + 2 * math.cos(sine / 38))), .2 / 3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
		end
	end
	if Mode == "Porple" then

		atho2.Rotation = Vector3.new(0, 0, -Sine + 10)

		HipVal = 2
		change = 1
		sensitivity = 25

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if not attack then
			if ChMove == false then
				if math.random(1,32+MusicReal.PlaybackLoudness/7) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(math.random(-100000-eee.PlaybackLoudness/7,100000+eee.PlaybackLoudness/7)), math.rad(math.random(-99999-eee.PlaybackLoudness/7,99999+eee.PlaybackLoudness/7)), math.rad(math.random(-200-eee.PlaybackLoudness/7,48375935+eee.PlaybackLoudness/7))),1/2)
				end
				if math.random(1,20+MusicReal.PlaybackLoudness/7) == 1 then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5 + 0.05 * math.sin(sine / 12), 0) * CFrame.Angles(math.rad(math.random(-90-eee.PlaybackLoudness/7,90+eee.PlaybackLoudness/7)), math.rad(math.random(-30-eee.PlaybackLoudness/7,30+eee.PlaybackLoudness/7)), math.rad(math.random(-50-eee.PlaybackLoudness/7,50+eee.PlaybackLoudness/7)))* RIGHTSHOULDERC0,1/2)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5 + 0.05 * math.sin(sine / 12), 0) * CFrame.Angles(math.rad(math.random(-10000-eee.PlaybackLoudness/7,10000+eee.PlaybackLoudness/7)), math.rad(math.random(-900-eee.PlaybackLoudness/7,900+eee.PlaybackLoudness/7)), math.rad(math.random(-20-eee.PlaybackLoudness/7,20+eee.PlaybackLoudness/7)))* LEFTSHOULDERC0,1/2)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0, 0, 1.5 + 1 * math.cos(sine / 39)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)),0.8)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)),1/2)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/25)), math.rad(math.random(-0.25,3)), math.rad(math.random(0.25,3)))* RIGHTSHOULDERC0, .7 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(40+eee.PlaybackLoudness/7.5), math.rad(0), math.rad(-10)) * LEFTSHOULDERC0,1)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1 , -1, 0) * CFrame.Angles(math.rad(0), math.rad(80+10* math.sin(sine / 78)), math.rad(0)) * CFrame.Angles(math.rad(-3+1* math.sin(sine / 58)), math.rad(0), math.rad(2.5+8 * math.sin(sine / 43))),0.8)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -0.5, -0.5) * CFrame.Angles(math.rad(0), math.rad(-80-10* math.sin(sine / 81)), math.rad(0)) * CFrame.Angles(math.rad(-3+1* math.sin(sine / 63)), math.rad(0), math.rad(0+15 * math.sin(sine / 49))),0.8)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
			elseif ChMove == true then
				Anim = "Walk"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 - 0.15 * math.cos(sine / 47), -0.5, 0.5 + 0.1 * math.cos(sine / 28)) * CFrame.Angles(math.rad(70), math.rad(0 - RootPart.RotVelocity.Y), math.rad(0 - RootPart.RotVelocity.Y * 4.5 + 3 * math.cos(sine / 47))), .2 / 3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(-17 - 5 * math.cos(sine / 52)), math.rad(0 - 3 * math.cos(sine / 37)), math.rad(0 + 2 * math.cos(sine / 78))), .2 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5 + 0.05 * math.cos(sine / 28), 0) * CFrame.Angles(math.rad(-8 - 4 * math.cos(sine / 59)), math.rad(-20 + 7 * math.cos(sine / 62)), math.rad(20 + 5 * math.cos(sine / 50)))* RIGHTSHOULDERC0, .2 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5 + 0.1 * math.cos(sine / 28), 0) * CFrame.Angles(math.rad(-8 - 3 * math.cos(sine / 55)), math.rad(20 + 8 * math.cos(sine / 67)), math.rad(-20 - 4 * math.cos(sine / 29))) * LEFTSHOULDERC0, .2 / 3)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1 , -0.5, -0.6) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(1.5), math.rad(0), math.rad(-20 - 5 * math.cos(sine / 34))), .2 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(1), math.rad(0), math.rad(20 + 2 * math.cos(sine / 38))), .2 / 3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
		end
	end
	if Mode == "Death" then

		atho2.Rotation = Vector3.new(0, 0, Sine + 10)

		HipVal = 2
		change = 1
		sensitivity = 25

		if attack == false then
			if ChMove == true then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 1 * SIN(Sine / 26)) * ANGLES(RAD(25 - 2.5*SIN(Sine/48/2)), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(Sine / 47))), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0 + 2.5 *COS(Sine / 12)), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(Sine/12)), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(Sine/12)), RAD(0), RAD(-12 + 4.10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif ChMove == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 1 * SIN(Sine / 26)) * ANGLES(RAD(-5 - 2.5*SIN(Sine/48/2)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0 + 2.5 *COS(Sine / 12)), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(Sine/12)), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(Sine/12)), RAD(0), RAD(-12 + 4.10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
		end
	end
	if Mode == "Cyber" then

		atho2.Rotation = Vector3.new(0, 0, -Sine + 10)

		HipVal = 1
		change = 1
		sensitivity = 25

		if attack == false then
			if ChMove==false then
				Anim = "Idle"
				RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0, 0, 0 + 0.25 * math.cos(sine / 12)) * CFrame.Angles(math.rad(4 + 2.5 * math.sin(sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, nc0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(15 + 4.5 * math.sin(sine / 12)), math.rad(0), math.rad(0 - 4 * math.sin(sine / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1, 0 + 0.025 * math.cos(sine / 12), -1) * CFrame.Angles(math.rad(25), math.rad(0 + 7.5 * math.sin(sine / 12)), math.rad(90 - 7.5 * math.sin(sine / 12))) * lscp, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, -0.01) * CFrame.Angles(math.rad(-7.5 * math.sin(sine / 12)), math.rad(75), math.rad(0)) * CFrame.Angles(math.rad(-8 - 2.5 * math.sin(sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -0.5, -0.5) * CFrame.Angles(math.rad(-7.5 * math.sin(sine / 12)), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(-8 - 2.5 * math.sin(sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			elseif ChMove==true then
				Anim = "Walk"
				RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0, 0, 0 + 0.25 * math.cos(sine / 12)) * CFrame.Angles(math.rad(15 + 2.5 * math.sin(sine / 12)), math.rad(0), math.rad(2.5 + 2.5 * math.sin(sine / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, nc0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(-10 + 4.5 * math.sin(sine / 12)), math.rad(0), math.rad(-2.5 - 2.5 * math.sin(sine / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1, 0 + 0.025 * math.cos(sine / 12), -1) * CFrame.Angles(math.rad(25), math.rad(0 + 7.5 * math.sin(sine / 12)), math.rad(90 - 7.5 * math.sin(sine / 12))) * lscp, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, -0.01) * CFrame.Angles(math.rad(-25-2.5 * math.sin(sine / 12)), math.rad(75), math.rad(0)) * CFrame.Angles(math.rad(-8 - 5.5 * math.sin(sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -0.5, -0.5) * CFrame.Angles(math.rad(-2.5 * math.sin(sine / 12)), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(-8 - 2.5 * math.sin(sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			end
		end
	end
	if Mode == "BigBan" then

		atho2.Rotation = Vector3.new(0, 0, Sine + 10)

		HipVal = 0
		change = 1
		sensitivity = 100

		if attack == false then
			if ChMove==true then
				RightHip.C0=obunga(RightHip.C0,CF(1,-1 - 0.1 * math.cos(Sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(-62* math.cos(Sine / 6))),.1)
				LeftHip.C0=obunga(LeftHip.C0,CF(-1,-1 - 0.1 * math.cos(Sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(-62* math.cos(Sine / 6))),.1)
				RootJoint.C0=obunga(RootJoint.C0,ROOTC0*CF(0,0.01 + 0.03 * math.cos(Sine / 6),0 + 0.1 * math.cos(Sine / 6))*angles(math.rad(-31 - 2 * math.cos(Sine / 20)),math.rad(0),math.rad(0)),.1)
				Neck.C0=obunga(Neck.C0,necko*angles(math.rad(-12 - 3 * math.cos(Sine / 40)),math.rad(0),math.rad(0 - 3 * math.cos(Sine / 67))),.1)
				RightShoulder.C0 = obunga(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(105 + 2 * math.cos(Sine / 20)), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = obunga(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-80*COS(Sine/6)), RAD(0), RAD(-12)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			elseif ChMove==false then
				RightHip.C0=obunga(RightHip.C0,CF(1,-1 - 0.1 * math.cos(Sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(-1 - 2 * math.cos(Sine / 20))),.1)
				LeftHip.C0=obunga(LeftHip.C0,CF(-1,-1 - 0.1 * math.cos(Sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(-1 + 2 * math.cos(Sine / 20))),.1)
				RootJoint.C0=obunga(RootJoint.C0,ROOTC0*CF(0,0.01 + 0.03 * math.cos(Sine / 20),0 + 0.1 * math.cos(Sine / 20))*angles(math.rad(1 - 2 * math.cos(Sine / 20)),math.rad(0),math.rad(-12)),.1)
				Neck.C0=obunga(Neck.C0,necko*angles(math.rad(3 - 3 * math.cos(Sine / 40)),math.rad(0),math.rad(12 + 3 * math.cos(Sine / 67))),.1)
				RightShoulder.C0 = obunga(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(60 + 4 * math.cos(Sine / 20)), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = obunga(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(7)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			end
		end
	end
	if Mode == "RainbowHell" then

		atho2.Rotation = Vector3.new(0, 0, -Sine + 10)

		HipVal = 0
		change = 1
		sensitivity = 16

		if attack == false then
			if ChMove==true then
				RootJoint.C0 = obunga(RootJoint.C0,ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(15), RAD(0), RAD(-7 * COS(Sine / (Humanoid.WalkSpeed)))), 1 / Animation_Speed)
				Neck.C0 = obunga(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(Sine / (Humanoid.WalkSpeed / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = obunga(RightShoulder.C0, CF(1.5, 0.55, 0) * ANGLES(RAD(180 - 5 * COS(Sine / 15)), RAD(0 - 5*SIN(MusicReal.PlaybackLoudness/500)), RAD(-5 + MusicReal.PlaybackLoudness/545)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = obunga(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(5), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = obunga(RightHip.C0,CFrame.new(1,-.9-.2*math.cos(Sine/12),.5*math.sin(Sine/12))*CFrame.Angles(math.rad(-10-40*math.sin(Sine/12)),math.rad(90+5*math.cos(Sine/12)),math.rad(2.5*math.cos(Sine/12))),.25)
				LeftHip.C0 = obunga(LeftHip.C0,CFrame.new(-1,-.9+.2*math.cos(Sine/12),-.5*math.sin(Sine/12))*CFrame.Angles(math.rad(-10+40*math.sin(Sine/12)),math.rad(-90+5*math.cos(Sine/12)),math.rad(2.5*math.cos(Sine/12))),.25)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			elseif ChMove==false then
				RootJoint.C0 = obunga(RootJoint.C0,ROOTC0 * CF(0 - 0.05 * COS(Sine / 20) + 0.05 * SIN(Sine / 20), 0, 0+MusicReal.PlaybackLoudness/1800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = obunga(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 + MRANDOM(-6,6)), RAD(0 + MRANDOM(-6,6)), RAD(0 - 10 * COS(Sine / 20) + MRANDOM(-6,6))), 1 / Animation_Speed)
				RightShoulder.C0 = obunga(RightShoulder.C0, CF(1.5, 0.55, 0) * ANGLES(RAD(180 - 5 * COS(Sine / 15)), RAD(0 - 5*SIN(MusicReal.PlaybackLoudness/500)), RAD(-5 + MusicReal.PlaybackLoudness/545)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = obunga(LeftShoulder.C0, CF(-1.45, 0.5, 0) * ANGLES(RAD(5 + MRANDOM(-6,6)), RAD(0 + MRANDOM(-6,6)), RAD(-15 + MRANDOM(-6,6))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = obunga(RightHip.C0, CF(1 - 0.05 * COS(Sine / 20) + 0.05 * SIN(Sine / 20), -1-MusicReal.PlaybackLoudness/1800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-6), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = obunga(LeftHip.C0, CF(-1 - 0.05 * COS(Sine / 20) + 0.05 * SIN(Sine / 20), -1-MusicReal.PlaybackLoudness/1800, -0.03) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-6), RAD(0), RAD(0)), 1 / Animation_Speed)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			end
		end
	end
	if Mode == "Zero" then

		atho2.Rotation = Vector3.new(0, 0, Sine + 10)

		HipVal = 1
		change = 1
		sensitivity = 50

		if attack == false then
			if ChMove==false then
				Anim = "Idle"
				RootJoint.C0 = Clerp(RootJoint.C0,rc0*CFrame.new(math.random(-1,1)/2,math.random(-1,1)/2,math.random(-1,1)/2)*CFrame.Angles(math.rad(math.random(-45,45)),math.rad(math.random(-45,45)),0),1)
				Neck.C0 = Clerp(Neck.C0,nc0,1)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(2,0,0) * rscp * CFrame.Angles(math.rad(-90),0,0),1)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-2,0,0) * lscp * CFrame.Angles(math.rad(-90),0,0),1)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(.5,-2,0),1)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-.5,-2,0),1)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			elseif ChMove==true then
				Anim = "Walk"
				RootJoint.C0 = Clerp(RootJoint.C0,rc0*CFrame.new(math.random(-1,1)/2,math.random(-1,1)/2,math.random(-1,1)/2)*CFrame.Angles(math.rad(math.random(-45,45)),math.rad(math.random(-45,45)),0),1)
				Neck.C0 = Clerp(Neck.C0,nc0,1)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(2,0,0) * rscp * CFrame.Angles(math.rad(-90),0,0),1)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-2,0,0) * lscp * CFrame.Angles(math.rad(-90),0,0),1)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(.5,-2,0),1)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-.5,-2,0),1)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			end
		end
	end
	if Mode == "GodCat" then

		atho2.Rotation = Vector3.new(0, 0, -Sine + 10)

		HipVal = 1
		change = 1
		sensitivity = 25

		if attack == false then
			if ChMove==false  then
				Anim = "Idle"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.1, 1 + 0.5 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(2.5), RAD(0), RAD(21 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed) 
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(100 + 2 * COS(SINE / 12)), RAD(0), RAD(15 + 3 * COS(SINE / 12) - 3 * SIN(SINE / 12))) *               ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(-3.5), RAD(-25 + 5 * COS(SINE / 12))) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(-20 + 1 * COS(SINE / 18)), RAD(0), RAD(-80)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.7) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(-35 + 1 * COS(SINE / 18)), RAD(0), RAD(80)), 1 / Animation_Speed)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
				if MRANDOM(1,32+eee.PlaybackLoudness/7) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-eee.PlaybackLoudness/7,100000+eee.PlaybackLoudness/7)), RAD(MRANDOM(-99999-eee.PlaybackLoudness/7,99999+eee.PlaybackLoudness/7)), RAD(MRANDOM(-200-eee.PlaybackLoudness/7,48375935+eee.PlaybackLoudness/7))), 1 / Animation_Speed) 
				end
				if MRANDOM(1,20+eee.PlaybackLoudness/7) == 1 then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-eee.PlaybackLoudness/7,90+eee.PlaybackLoudness/7)), RAD(MRANDOM(-30-eee.PlaybackLoudness/7,30+eee.PlaybackLoudness/7)), RAD(MRANDOM(-50-eee.PlaybackLoudness/7,50+eee.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-eee.PlaybackLoudness/7,10000+eee.PlaybackLoudness/7)), RAD(MRANDOM(-900-eee.PlaybackLoudness/7,900+eee.PlaybackLoudness/7)), RAD(MRANDOM(-20-eee.PlaybackLoudness/7,20+eee.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end
			elseif ChMove==true then
				Anim = "Walk"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.15 * COS(SINE / 47), -0.5, 0.5 + 0.1 * COS(SINE / 28)) * ANGLES(RAD(70), RAD(0 - RootPart.RotVelocity.Y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), .2 / 3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-17 - 5 * COS(SINE / 52)), RAD(0 - 3 * COS(SINE / 37)), RAD(0 + 2 * COS(SINE / 78))), .2 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * COS(SINE / 28), 0) * ANGLES(RAD(-8 - 4 * COS(SINE / 59)), RAD(-20 + 7 * COS(SINE / 62)), RAD(20 + 5 * COS(SINE / 50)))* RIGHTSHOULDERC0, .2 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.1 * COS(SINE / 28), 0) * ANGLES(RAD(-8 - 3 * COS(SINE / 55)), RAD(20 + 8 * COS(SINE / 67)), RAD(-20 - 4 * COS(SINE / 29))) * LEFTSHOULDERC0, .2 / 3)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -0.5, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(1.5), RAD(0), RAD(-20 - 5 * COS(SINE / 34))), .2 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(1), RAD(0), RAD(20 + 2 * COS(SINE / 38))), .2 / 3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)		
			end
		end
	end
	if Mode == "HLC - as" then

		atho2.Rotation = Vector3.new(0, 0, Sine + 10)

		HipVal = 2
		change = 1
		sensitivity = 35

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if attack == false then
			if ChMove == false then
				Anim = "Idle"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,math.cos(sine/15))*CFrame.Angles(math.rad(20* math.sin(sine/15)),0,0),.25)
				Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(10-5*math.cos(sine/12)),math.rad(10*math.cos(sine/12)),math.rad(5*math.cos(sine/12))),.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5+0.1*math.cos(sine/12),0)*CFrame.Angles(math.rad(-75+1.75*math.cos(sine/12)),0,math.rad(5))*RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1, 0.5, -0.6) * CFrame.Angles(math.rad(165), math.rad(0), math.rad(50)) * LEFTSHOULDERC0, 0.15 / 3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.4,-0.5)*CFrame.Angles(math.rad(0 + 6.5 * math.sin(sine/12)),math.rad(90),math.rad(40*math.sin(sine/34)))*CFrame.Angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 36)),math.rad(-10 - 2 * math.cos(sine / 39))),0.2)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(10 + 4.6 * math.sin(sine/12)),math.rad(-90),math.rad(20*math.sin(sine/34)))*CFrame.Angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 36)),math.rad(10 + 6 * math.cos(sine / 31))),0.2)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
			elseif ChMove == true then
				local ncs = false
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,-.5*math.sin(sine/12.5))*CFrame.Angles(math.rad(40),0,0),.25)
				if ncs then
					Neck.C0 = Clerp(Neck.C0, NECKC0*CFrame.Angles(math.rad(-25),math.rad(10*math.sin(sine/25)),0),1)
					ncs = false
				else
					Neck.C0 = Clerp(Neck.C0, NECKC0*CFrame.Angles(math.rad(-25),math.rad(10*math.sin(sine/25)),0),.25)
				end
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(90-4*math.sin(sine/25)), math.rad(5+2* math.sin(sine/25+math.random(-0.25,3))), math.rad(-2+5*math.sin(sine / 25))) * LEFTSHOULDERC0, .7 / 3)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-30-4*math.sin(sine/25-math.random(0.25,3))), math.rad(80), math.rad(0)), .7 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 , 0) * CFrame.Angles(math.rad(-20-4*math.sin(sine/25-math.random(-0.25,3))), math.rad(-80), math.rad(0)), .7 / 3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			end
		end
	end
	if Mode == "HLC - ho" then

		atho2.Rotation = Vector3.new(0, 0, -Sine + 10)

		HipVal = 0
		change = 1
		sensitivity = 35

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if not attack then
			if ChMove == false then
				local headsnap = math.random(1,60);
				local headsnapping=false;
				if headsnap == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(500,500)), math.rad(math.random(500,500)), math.rad(math.random(500,500))), 1)headsnapping=true headsnapping=false
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0, 0, 0 + 0.05 * math.cos(sine / 12)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-0)), 1 / 3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) *CFrame.Angles(math.rad(20 - 2.5 * math.sin(Sine / 12)), math.rad(0), math.rad(30 *math.cos(sine/12))), 1 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(Sine/50))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1 - 0.05 * math.cos(sine / 12), -0.01) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(-8), math.rad(0), math.rad(0)), 1 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 - 0.05 * math.cos(sine / 12), -0.01) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(-8), math.rad(0), math.rad(0)), 1 / 3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
			elseif ChMove == true then
				Anim = "Walk"
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(10 - 2* math.sin(sine / 3)), math.rad(0), math.rad(0-5 * math.sin(sine / 6))),0.8)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0,1)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(-12)) * LEFTSHOULDERC0,0.8)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0, 0, -0.1+0.15* math.sin(sine / 3)) * CFrame.Angles(math.rad(15+3 * math.sin(sine / 3)), math.rad(0), math.rad(0+5 * math.sin(sine / 6))),0.8)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1 , -1, 0) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-5 + 70 * math.sin(sine / 6))),0.8)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(5 + 70 * math.sin(sine / 6))),0.8)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			end
		end
	end
	if Mode == "HLC - uw" then

		atho2.Rotation = Vector3.new(0, 0, Sine + 10)

		HipVal = 1
		change = 1
		sensitivity = 35

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		if attack == false then
			if ChMove == false then
				Anim = "Idle"
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,-.5*math.sin(sine/25)) * CFrame.Angles(math.rad(-90+5*math.cos(sine/25)),math.rad(0),math.rad(0)),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.1,0) * CFrame.Angles(math.rad(25+5*math.cos(sine/25)),math.rad(0),math.rad(0)),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1,.75,.1) * CFrame.Angles(math.rad(-165.1-5*math.cos(sine/25)),math.rad(0),math.rad(-40)) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1,.75,.1) * CFrame.Angles(math.rad(-165-5*math.cos(sine/25)),math.rad(0),math.rad(40)) * LEFTSHOULDERC0,.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(0+10*math.cos(sine/25)),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(25+10*math.cos(sine/25)),math.rad(-90),math.rad(0)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.7/3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif ChMove == true then
				local ncs = false
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,-.5*math.sin(sine/12.5))*CFrame.Angles(math.rad(40),0,0),.25)
				if ncs then
					Neck.C0 = Clerp(Neck.C0, NECKC0*CFrame.Angles(math.rad(-25),math.rad(10*math.sin(sine/25)),0),1)
					ncs = false
				else
					Neck.C0 = Clerp(Neck.C0, NECKC0*CFrame.Angles(math.rad(-25),math.rad(10*math.sin(sine/25)),0),.25)
				end
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(90-4*math.sin(sine/25)), math.rad(5+2* math.sin(sine/25+math.random(-0.25,3))), math.rad(-2+5*math.sin(sine / 25))) * LEFTSHOULDERC0, .7 / 3)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-30-4*math.sin(sine/25-math.random(0.25,3))), math.rad(80), math.rad(0)), .7 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 , 0) * CFrame.Angles(math.rad(-20-4*math.sin(sine/25-math.random(-0.25,3))), math.rad(-80), math.rad(0)), .7 / 3)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			end
		end
	end
	if Mode == "HLC - rars" then

		atho2.Rotation = Vector3.new(0, 0, -Sine + 10)

		HipVal = 0
		change = 1
		sensitivity = 35

		RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		if attack == false then
			if ChMove == false then
				Anim = "Idle"
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.Angles(math.rad(5*math.cos(sine/25)),0,0),.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0,1)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0, 0, -0.11 + 0.2 * math.cos(sine / 34)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)),0.8)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(5 * math.cos(sine / 24)), math.rad(0), math.rad(-10 - 5.5 *  math.cos(sine / 34))) * LEFTSHOULDERC0,0.8)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1 - 0.1 * math.cos(sine / 34), -0.01) * CFrame.Angles(math.rad(0), math.rad(80), math.rad(0)) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)),0.8)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 - 0.1 * math.cos(sine / 34), -0.01) * CFrame.Angles(math.rad(0), math.rad(-80), math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0), math.rad(0)),0.8)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif ChMove == true then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(10 - 2* math.sin(sine / 3)), math.rad(0), math.rad(0-5 * math.sin(sine / 6))),0.8)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0,1)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(-12)) * LEFTSHOULDERC0,0.8)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0, 0, -0.1+0.15* math.sin(sine / 3)) * CFrame.Angles(math.rad(15+3 * math.sin(sine / 3)), math.rad(0), math.rad(0+5 * math.sin(sine / 6))),0.8)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1 , -1, 0) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-5 + 70 * math.sin(sine / 6))),0.8)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(5 + 70 * math.sin(sine / 6))),0.8)
				gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			end
		end
	end
	if Mode == "Blood" then
		if ChMove == false then
			if attack == false then
				Neck.C0 = spicy.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(7 + 6.5 * SIN(SINE / 24)), RAD(10*SIN(SINE/24)), RAD(6*SIN(SINE/24))), 0.5 / Animation_Speed)
				RightShoulder.C0 = spicy.OG(RightShoulder.C0, CF(1.5,0.5,0) * ANGLES(RAD(120 + 6.5 * SIN(SINE / 34)), RAD(5*SIN(SINE/34)), RAD(10 * SIN(SINE / 34))) * ANGLES(RAD(5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				RootJoint.C0 = spicy.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 1.5 + 0.5 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.4 / Animation_Speed)
				LeftShoulder.C0 = spicy.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(1), RAD(0), RAD(22)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
				RightHip.C0=spicy.OG(RightHip.C0,CF(1,-0.4,-0.5)*ANGLES(RAD(0 + 6.5 * SIN(SINE/12)),RAD(90),RAD(40*SIN(SINE/34)))*ANGLES(RAD(-3),RAD(0 - 1 * COS(SINE / 36)),RAD(-10 - 2 * COS(SINE / 39))),0.2)
				LeftHip.C0=spicy.OG(LeftHip.C0,CF(-1,-1,0)*ANGLES(RAD(10 + 4.6 * SIN(SINE/12)),RAD(-90),RAD(20*SIN(SINE/34)))*ANGLES(RAD(-3),RAD(0 - 1 * COS(SINE / 36)),RAD(10 + 6 * COS(SINE / 31))),0.2)
			end
		elseif ChMove == true then
			Anim = "Walk"
			if attack == false then
				RootJoint.C0 = spicy.OG(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = spicy.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
				RightShoulder.C0 = spicy.OG(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = spicy.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				RightHip.C0 = spicy.OG(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				LeftHip.C0 = spicy.OG(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			end
		end
	end
end)
-- Smooth Loop --
function swait(t)
	game:GetService('RunService').Stepped:wait()
end
local flinging = false
local getChild = nil
local bambam = ThrusterThing
local Effects = Instance.new("Folder",Character)
local function GetCHILD(CHILD)
	if CHILD:FindFirstChildWhichIsA("Humanoid").RigType == Enum.HumanoidRigType.R6 then
		getChild = CHILD.Torso
	else
		getChild = CHILD.UpperTorso
	end
end
function Fling(MODEL)
	local HUM = MODEL:FindFirstChildOfClass("Humanoid")
	if HUM and MODEL.Name ~= CloneChar.Name and MODEL.Name ~= Character.Name then
		GetCHILD(MODEL)

		--flinging = true
		for i =1,24 do
			local Parttofling = MODEL:FindFirstChild("HumanoidRootPart") or MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
			bambam.Parent = workspace
			HumanRoot.Position = Parttofling.Position
			--bambam.Parent = HumanRoot
			i = i +1
			wait()
		end
		bambam.Parent = HumanRoot
	end
end
function ApplyAoE(POSITION,RANGE)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso") or CHILD:FindFirstChild("HumanoidRootPart")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						Fling(CHILD)
					end
				end
			end
		end
	end
end

if SetHeadless == true then
	workspace[Player.Name].Head:Destroy()
	Character.Head.face:Destroy()
end

local Mouse = Player:GetMouse()
function EFFECT1(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part",Effects)
	rng.Anchored = true
	rng.Color = GUN.NeonParts.Color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh",rng)
	rngm.MeshType = "Brick"
	rngm.Scale = Vector3.new(x1,y1,z1)
	local scaler2 = 1
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - .01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - .01/value*bonuspeed
			end
			rng.Color = GUN.NeonParts.Color
			speeder = speeder - .01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + .01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed,scaler2*bonuspeed,scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end
function TPEffect(pos)
	for xd = 1,5 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.15,0,.15),Transparency = 0,Transparency2 = 1,CFrame = pos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = neonpart.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.15,0,.15),Transparency = 0,Transparency2 = 1,CFrame = pos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = neonpart.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	for i = 0, 14 do
		EFFECT1(3,math.random(4,8),"Add",pos*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.03,GUN.NeonParts.Color,0)
	end
end
function tp(NEWPOS)
	local pos = NEWPOS+Vector3.new(0,2.5,0)
	pos = CFrame.new(pos.X,pos.Y,pos.Z)
	local oldpos = RootPart.CFrame
	RootPart.CFrame = pos
	makesound("rbxassetid://1177785010",1,10,RootPart,999999,999999,true):Play()
	coroutine.wrap(TPEffect)(pos)
end
local CanAttack = true

local S = Instance.new("Sound")
function CreateSound(ID,PARENT,VOLUME,PITCH,DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://"..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			coroutine.resume(coroutine.create(function()
				pcall(function()
					repeat if stopeverything then wait(math.huge) end Swait() until NEWSOUND.Playing == false
					NEWSOUND:Destroy()
				end)
			end))
		end
	end))
	return NEWSOUND
end
function CreateMesh(MESH,PARENT,MESHTYPE,MESHID,TEXTUREID,SCALE,OFFSET)
	local NEWMESH = Instance.new(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" and tonumber(MESHID) ~= nil then
			NEWMESH.MeshId = "rbxassetid://"..MESHID
		elseif MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "rbxassetid://"..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or Vector3.new()
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end
function CreatePart(FORMFACTOR,PARENT,MATERIAL,REFLECTANCE,TRANSPARENCY,BRICKCOLOR,NAME,SIZE,ANCHOR)
	local NEWPART = Instance.new("Part")
	NEWPART.Massless = true
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.Color = BRICKCOLOR
	NEWPART.Name = randomstring()
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
function Effect(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or Color3.fromRGB(0,0,0))
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,Color3.fromRGB(0,0,0),"Effect",Vector3.new(1,1,1),true)
		if RAINBOWPART then
			coroutine.resume(coroutine.create(function()
				while not stopeverything and EFFECT:IsDescendantOf(game) do
					EFFECT.Color = neonpart.Color
					swait()
				end
			end))
		end
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","168892432","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1,TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1,TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat if stopeverything then wait(math.huge) end swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat if stopeverything then wait(math.huge) end swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		end
	end))
end
function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = Instance.new("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = Instance.new("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = Instance.new("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or Color3.fromRGB(0,0,0))
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,Color3.fromRGB(0,0,0),"Effect",Vector3.new(1,1,1),true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		if RAINBOWPART then
			coroutine.resume(coroutine.create(function()
				while not stopeverything and EFFECT:IsDescendantOf(game) do
					EFFECT.Color = neonpart.Color
					swait()
				end
			end))
		end
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = Vector3.new(SIZE.X,SIZE.Y,SIZE.Z)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","1051557","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			EFFECT.CFrame = CFRAME
			for LOOP = 1,TIME+1 do
				swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = Vector3.new(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat if stopeverything then wait(math.huge) end swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat if stopeverything then wait(math.huge) end swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end
function Ka_Boom()
	attack = true
	CanAttack = false
	endp = RootPart.Position
	coroutine.wrap(function()
		for i = 0,2 do
			wait(.12)
			CreateSound(199145095,GUN.Joint,10,1)
		end
	end)()
	for i = 0,2,.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1/2)
	end
	for i = 0,2,.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	local BEAM = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
	local BEAM2 = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
	MakeForm(BEAM,"Ball")
	MakeForm(BEAM2,"Ball")
	BEAM.CFrame = CFrame.new(RootPart.Position)
	BEAM2.CFrame = CFrame.new(RootPart.Position)
	local boooom = CreateSound(415700134,RootPart,10,1,false)
	boooom.EmitterSize = 100
	CamShake(15,5)
	coroutine.wrap(ApplyAoE)(endp,35)
	for i=1,140 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,-.2,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		BEAM.Size = BEAM.Size + Vector3.new(.7,8,.7)
		BEAM2.Size = BEAM2.Size + Vector3.new(2,2,2)
		BEAM.Color = neonpart.Color
		BEAM2.Color = neonpart.Color
		BEAM.CFrame = CFrame.new(RootPart.Position)
		BEAM2.CFrame = CFrame.new(RootPart.Position)
		WACKYEFFECT({TIME = 5+i,EffectType = "Swirl",Size = BEAM2.Size*1.15,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = .8,Transparency2 = 1,CFrame = BEAM.CFrame * CFrame.Angles(math.rad(0),math.rad(math.random(-360,360)),math.rad(0)),MoveToPos = nil,RotationX = 0,RotationY = math.random(-9,9),RotationZ = 0,Material = "Neon",Color = neonpart.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
	end
	Effect({TIME = 75,EffectType = "Sphere",Size = BEAM.Size,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = 0,Transparency2 = 0,CFrame = BEAM.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = Color3.fromRGB(0,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil})
	Effect({TIME = 75,EffectType = "Sphere",Size = BEAM2.Size,Size2 = Vector3.new(),Transparency = 0,Transparency2 = .6,CFrame = BEAM2.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = Color3.fromRGB(0,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil})
	for i,v in pairs(Effects:GetChildren()) do
		v.Color = Color3.fromRGB(0,0,0)
		v:GetPropertyChangedSignal("Color"):Connect(function()
			v.Color = Color3.fromRGB(0,0,0)
		end)
	end
	BEAM2:Destroy()
	BEAM:Destroy()
	attack = false
	CanAttack = true
end
function Emote3()
	attack = true
	CanAttack = false
	endp = RootPart.Position
	coroutine.wrap(function()
		for i = 0,2 do
			wait(.12)
			CreateSound(199145095,GUN.Joint,10,1)
		end
	end)()
	for i = 0,2,.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1/2)
	end
	attack = false
	CanAttack = true
end

local Plr = Player

local Gui = game:GetObjects("rbxassetid://8497275682")[1]
Gui.Parent = Player.PlayerGui

local brandnewegg = Instance.new("Sound")
brandnewegg.SoundId = "rbxassetid://515150941"
brandnewegg.Volume = 1
brandnewegg.PlaybackSpeed = .8
brandnewegg.PlayOnRemove = true

local function CreateNewMessage(Message)
	local Timer = tick()
	--coroutine.wrap(processchat)(Message,false)
	spawn(function()
		repeat
			game:GetService("RunService").RenderStepped:Wait()
		until tick()-Timer >= 1
	end)
	local LastLen = 0
	local AddMessage = Gui.ChatFolder.Template:Clone()
	AddMessage.Name = randomstring()
	AddMessage.Parent = Gui.ChatFolder.Chats
	AddMessage.Visible = true
	AddMessage:TweenPosition(UDim2.new(0,0,.95,0))
	repeat
		game:GetService('RunService').RenderStepped:Wait()
		local Len = math.floor((tick()-Timer)*30)
		if Len > LastLen then
			LastLen = Len
		end
		local g = brandnewegg:Clone()
		g.Parent = game:GetService("Chat")
		g:Destroy()
		AddMessage.Text = "["..Plr.Name.."]: "..string.sub(Message,0,Len)
	until tick()-Timer >= string.len(Message)/30
	AddMessage.Text = "["..Plr.Name.."]: "..Message
	Timer = tick()
	repeat
		game:GetService("RunService").RenderStepped:Wait()
	until tick()-Timer >= 3
	AddMessage.Text = "["..Plr.Name.."]: "..randomstring()
	game:GetService("TweenService"):Create(AddMessage,TweenInfo.new(1,Enum.EasingStyle.Linear),{TextTransparency = 1,TextStrokeTransparency = 1}):Play()
	local g = Instance.new("Sound",game:GetService("Chat"))
	g.SoundId = "rbxassetid://749189256"
	g.PlaybackSpeed = 1
	g.Volume = .5
	g.Name = randomstring()
	g.PlayOnRemove = true
	g:Play()
	g:Destroy()
	wait(1)
	AddMessage:Destroy()
end

function respawncharlol()
	for i, v in next, workspace:GetDescendants() do
		if v:IsA("SpawnLocation") then
			local newpos = v.CFrame * CFrame.new(0,v.Size.Y/2+30,0).Position
			CloneChar.HumanoidRootPart.CFrame = CFrame.new(newpos)
			return
		end
	end
end

local NetLagOthers = false
local MuteOthers = false
local FLYING = false
local ISFLYING = false

local stopall = false
local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(function(Input, chatting)
	if stopall == false then
		if Input.KeyCode == Enum.KeyCode.M and CanAttack == true and not chatting then

			if Mode == "None" then
				ChangeMode("Amalgam")
			elseif Mode == "Amalgam" then
				ChangeMode("Fast")
			elseif Mode == "Fast" then
				ChangeMode("Zeke")
			elseif Mode == "Zeke" then
				ChangeMode("Lord")
			elseif Mode == "Lord" then
				ChangeMode("Trussing")
			elseif Mode == "Trussing" then
				ChangeMode("NDaD")
			elseif Mode == "NDaD" then
				ChangeMode("|")
			elseif Mode == "|" then
				ChangeMode("IDK")
			elseif Mode == "IDK" then
				ChangeMode("Banisher2")
			elseif Mode == "Banisher2" then
				ChangeMode("LC")
			elseif Mode == "LC" then
				ChangeMode("MLC")
			elseif Mode == "MLC" then
				ChangeMode("Kick")
			elseif Mode == "Kick" then
				ChangeMode("PetFroge")
			elseif Mode == "PetFroge" then
				ChangeMode("Porple")
			elseif Mode == "Porple" then
				ChangeMode("Death")
			elseif Mode == "Death" then
				ChangeMode("Cyber")
			elseif Mode == "Cyber" then
				ChangeMode("BigBan")
			elseif Mode == "BigBan" then
				ChangeMode("RainbowHell")
			elseif Mode == "RainbowHell" then
				ChangeMode("Zero")
			elseif Mode == "Zero" then
				ChangeMode("GodCat")
			elseif Mode == "GodCat" then
				ChangeMode("HLC - as")
			elseif Mode == "HLC - as" then
				ChangeMode("HLC - ho")
			elseif Mode == "HLC - ho" then
				ChangeMode("HLC - uw")
			elseif Mode == "HLC - uw" then
				ChangeMode("HLC - rars")
			elseif Mode == "HLC - rars" then
				ChangeMode("Blood")
			elseif Mode == "Blood" then
				ChangeMode("None")
			end
		end
		if Input.KeyCode == Enum.KeyCode.R and CanAttack == true and not chatting then
			if Mouse.Target and Mouse.Target.Parent then
				tp(Mouse.Hit)
			end
		end
		if Input.KeyCode == Enum.KeyCode.G and not chatting then
			if NetLagOthers == false then
				NetLagOthers = true
				coroutine.wrap(CreateNewMessage)("NetLagOthers has been set to true.")
			elseif NetLagOthers == true then
				NetLagOthers = false
				coroutine.wrap(CreateNewMessage)("NetLagOthers has been set to false.")
			end
		end
		if Input.KeyCode == Enum.KeyCode.H and not chatting then
			if MuteOthers == false then
				MuteOthers = true
				coroutine.wrap(CreateNewMessage)("MuteOthers has been set to true.")
			elseif MuteOthers == true then
				MuteOthers = false
				coroutine.wrap(CreateNewMessage)("MuteOthers has been set to false.")
			end
		end
		if Input.KeyCode == Enum.KeyCode.F and not chatting then
			ISFLYING = not ISFLYING
			sFLY()
		end
		if Input.KeyCode == Enum.KeyCode.B and AttackType == "Shoot" and CanAttack == true and not chatting then
			Ka_Boom()
		end
		if Input.KeyCode == Enum.KeyCode.U and AttackType == "Shoot" and CanAttack == true and not chatting then
			Emote3()
		end
		if Input.KeyCode == Enum.KeyCode.P and CanAttack == true and not chatting then
			respawncharlol()
		end
	end
end)

-- Shooty Thing lol --
local TweenService = game:GetService("TweenService")

turnto = function(position)
	CloneChar.HumanoidRootPart.CFrame=CFrame.new(CloneChar.HumanoidRootPart.CFrame.p,Vector3.new(position.X,CloneChar.HumanoidRootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end
local LerpStyle = function(lerpmagnet,easingstyle,easingdirection)
	local newstyle = TweenService:GetValue(lerpmagnet,easingstyle,easingdirection)
	return newstyle
end
local xz = false
makesound = function(soundid,speed,volume,parent,Max,Min,Por)
	local sound = Instance.new("Sound")
	sound.SoundId = soundid
	sound.RollOffMaxDistance = Max
	sound.RollOffMinDistance = Min
	sound.PlaybackSpeed =speed 
	sound.Volume = volume
	sound.Parent = parent
	sound.PlayOnRemove = Por
	repeat
		wait()
	until sound.Loaded
	sound:Destroy()
	return sound
end
local tors = Torso
local root = CloneChar.HumanoidRootPart.RootJoint.C0
local rs = tors["Right Shoulder"].C0
local ls = tors["Left Shoulder"].C0
local rh = tors["Right Hip"].C0
local lh = tors["Left Hip"].C0

local MakeTween = function(timetack,easingstyle,easingdirection,repeats,flipflop)
	local newtween = TweenInfo.new(
		timetack, 
		easingstyle, 
		easingdirection, 
		repeats, 
		flipflop, 
		0 
	)
	return newtween
end
function ShootThing(startp,endp,amount,offst,Size)
	CamShake(1.5,5)
	local FlingPartPositioner = Instance.new("Part")
	FlingPartPositioner.Anchored = true
	FlingPartPositioner.Transparency = 1
	FlingPartPositioner.CanCollide = false
	FlingPartPositioner.Size = Vector3.new(0,0,0)
	FlingPartPositioner.Position = endp
	bambam.Parent = workspace

	local FakeBam = bambam:Clone()
	FakeBam.Parent = HumanRoot
	FakeBam.Location = FlingPartPositioner.Position
	HumanRoot.Velocity = Vector3.new(0,0,0)
	local f = coroutine.create(function()
		local ptab = {}
		for i = 0,amount do
			local offset = Vector3.new(math.random(-offst,offst),math.random(-0,offst),math.random(-offst,offst))
			if i == 0 or i == amount then
				offset = Vector3.new(0,0,0)
			end
			local pos = startp + (endp - startp).Unit * i * (endp - startp).Magnitude / amount + offset
			ptab[#ptab + 1] = pos + offset
		end
		for i = 1, #ptab do
			if ptab[i + 1] ~= nil then
				if i > 100 then
					break
				end

				local lght = Instance.new("Part")
				lght.Material = "Neon"
				lght.CanCollide = false
				lght.Anchored = true
				lght.Size = Vector3.new(Size,Size,(ptab[i] - ptab[i + 1]).Magnitude)
				lght.CFrame = CFrame.new((ptab[i] + ptab[i + 1])/2, ptab[i + 1])
				local twn = MakeTween(0.5,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut,0,false)
				local ST = lght.Position
				local ltwn = TweenService:Create(lght, twn,{Size = Vector3.new(0,0,lght.Size.Z)})
				lght.Parent = CloneChar
				ltwn:Play()
				game.Debris:AddItem(lght,0.5)
				lght.Color = neonpart.Color
				if i == #ptab-1 then
					local SP = Instance.new("Part")
					SP.CanCollide = false
					SP.Anchored = true
					SP.Parent = workspace
					SP.Size = Vector3.new(0,0,0)
					SP.Position = lght.Position
					game.Debris:AddItem(SP,10)
				end
			else
				lIT = true
				ApplyAoE(endp,12)
				FakeBam.Location = endp				
				HumanRoot.Position = endp

				wait(0.5)
				FakeBam:Destroy()
				bambam.Parent = HumanRoot
				lIT = false				
				break
			end
		end
	end)
	coroutine.resume(f)
end
local GunTip = Instance.new("Attachment")
GunTip.Parent = Holetwo

function Attack(Position)
	if attack == false then
		attack = true
		-- woah --
		turnto(Position)
		for i =1,12 do
			swait()
			RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF(0,0,2 + math.sin(time()/4.7)*-1) * CFA(0,0,math.rad(20)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
			tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(112)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
			tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(-12),0,math.rad(0)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
			tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.43,0.4,0.1) * CFA(0,math.rad(-16),math.rad(-12)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
			tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(-0.45,0.41,0.13)  * CFA(0,math.rad(19),math.rad(24)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
			gunweld.C0 = Clerp(gunweld.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
		end
		makesound("rbxassetid://3723700663",1,10,workspace,999999,999999,true):Play()
		for i =1,2 do
			ShootThing(GunTip.WorldPosition,Position, math.floor((RootPart.Position - Position).Magnitude/10),3 ,1.6)
		end
		attack = false
	end
end

function Sword()
	attack = true
	CanAttack = false
	endp = RootPart.Position
	for i = 0,.5,.05 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(85)) * rscp,1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(0)) * lscp,1 / 3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
		gunweld.C0 = Clerp(gunweld.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(180),math.rad(90),math.rad(0)),1 / 2)
	end
	CreateSound(6241709963,GunPos,5,1+(math.random(-4,4)/20),false)
	for i = 0,.5,.075 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(60)),1 / 3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-60)),1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-90)) * rscp,1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1 / 3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(75),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-65),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
		gunweld.C0 = Clerp(gunweld.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(180),math.rad(90),math.rad(0)),1 / 2)
	end
	coroutine.wrap(ApplyAoE)(endp,8)
	attack = false
	CanAttack = true
end

local Mouse = Player:GetMouse()
local B1Hold = false
Mouse.Button1Down:Connect(function()
	B1Hold = true 
	while B1Hold == true and CanAttack == true do
		if AttackType == "Shoot" then
			wait()
			Attack(Mouse.Hit.Position)
		elseif AttackType == "Sword" then
			wait()
			Sword()
		end
	end
end)
Mouse.Button1Up:Connect(function()
	B1Hold = false
end)

-- Shooty Thing lol --

--[[local function processchat(textt,glitchy)
	local text = string.gsub(textt,"​","")
	local chat = coroutine.wrap(function()
		ischattinglol = true
		for i = 1,string.len(text) do
			swait(2)
			TextHolder.Text = string.sub(text,1,i)
			TextHolder.Text = string.sub(text,1,i)
		end
		wait(4)
		TextHolder.Text = randomstring()
		wait(1)
		ischattinglol = false
	end)
	chat()
end]]

Player.Chatted:Connect(function(Message)
	coroutine.wrap(CreateNewMessage)(Message)
end)
FPSCounter.LeaveGame.Text = "Stop Script"
FPSCounter.LeaveGame.MouseButton1Click:Connect(function()
	for i,v in pairs(NominatedDeadChar:GetChildren()) do
		if v:IsA("BasePart") then
			v.Anchored = true
		end
		if v:IsA("Accessory") then
			v.Handle.Anchored = true
		end
	end
	for i,v in pairs(Character:GetChildren()) do
		if v:IsA("BasePart") then
			v.Anchored = true
		end
		if v:IsA("Accessory") then
			v.Handle.Anchored = true
		end
	end
	if AudioReplication == true then
		ReplicationBoombox.Handle.Anchored = true
	end
	resetBindable:Fire()
	FRB:Destroy()
	HiddenPlace:Destroy()
	NetLagOthers = false
	MuteOthers = false
	stopall = true
	game:GetService("StarterGui"):SetCore("SendNotification",{
		Title = "Script stopped!",
		Text = "The script has been stopped.",
		Button1 = "Okay"
	})
	script.Disabled = true
end)

-- TV Screen Setup --
local ChatBlock = Instance.new("Part")
ChatBlock.Anchored = true
ChatBlock.Parent = Character
ChatBlock.Transparency = 1
ChatBlock.CanCollide = false
ChatBlock.CFrame = Torso.CFrame

local athpchat = Instance.new("Attachment",ChatBlock)
athpchat.Name = "athpchat"
local athochat = Instance.new("Attachment",ChatBlock)
athochat.Name = "athochat"

NominatedDeadChar["Nagamaki"].Handle.SpecialMesh:Destroy()
Character["Nagamaki"].Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athpchat
Character["Nagamaki"].Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = athochat
athochat.Rotation = Vector3.new(0, 0, 0)
athpchat.Position = Vector3.new(0, 0, 0)

if AudioReplication == true then -- sin cause tan, get it?
	ReplicationBoombox.Remote:FireServer("PlaySong",string.split(MusicReal.SoundId,"rbxassetid://")[2])
	spawn(function()
		MusicReal.Volume = 0
		ReplicationBoombox.Handle:FindFirstChildWhichIsA("SpecialMesh"):Destroy()
		SCIFIMOVIELOL(ReplicationBoombox.Handle,ChatBlock,Vector3.new(0,0,0),Vector3.new(0,0,0))
		local csong = ""
		MusicReal.Changed:Connect(function(t)
			if t == "SoundId" then
				ReplicationBoombox.Remote:FireServer("PlaySong",string.split(MusicReal.SoundId,"rbxassetid://")[2])
			end
		end)
	end)
end

local function chattween(instance,properties,duration,easingdirection,easingstyle)
	spawn(function()
		if easingstyle == nil then easingstyle = Enum.EasingStyle.Quad end
		game:GetService("TweenService"):Create(instance,TweenInfo.new(duration,easingstyle,easingdirection),properties):Play()
	end)
end

local alreadyfixing = false

local iyflyspeed = .95
function sFLY()
	if ISFLYING == false then
		FLYING = false
	else
		local RootMoverPart = CloneChar.HumanoidRootPart
		local CONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
		local lCONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
		local SPEED = 0		


		local function FLY()
			FLYING = true
			BG = Instance.new('BodyGyro',RootMoverPart)
			BV = Instance.new('BodyVelocity',RootMoverPart)
			BG.Name = randomstring()
			BV.Name = randomstring()
			BG.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
			BG.P = 1e4
			BG.CFrame = RootMoverPart.CFrame
			BV.Velocity = Vector3.new(0,0,0)
			BV.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
			coroutine.resume(coroutine.create(function()
				repeat 
					swait()
					if not alreadyfixing then
						if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
							SPEED = 50
							--print("flying")
						elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
							SPEED = 0
							--print("stopped flew")
						end

						local vector = workspace.CurrentCamera.CoordinateFrame.LookVector

						if CONTROL.L == -1 then
							vector = -workspace.CurrentCamera.CoordinateFrame.RightVector
						elseif CONTROL.R == 1 then
							vector = workspace.CurrentCamera.CoordinateFrame.RightVector
						end

						if CONTROL.F == 1 then
							vector = workspace.CurrentCamera.CoordinateFrame.LookVector
						elseif CONTROL.B == -1 then
							vector = -workspace.CurrentCamera.CoordinateFrame.LookVector
						end

						if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
							BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.LookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R,(CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2,0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
							lCONTROL = {F = CONTROL.F,B = CONTROL.B,L = CONTROL.L,R = CONTROL.R}
						elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
							BV.Velocity = ((vector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R,(lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2,0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
						else
							BV.Velocity = Vector3.new(0,0,0)
						end
						if SPEED ~= 0 then
							BG.CFrame = CFrame.new(RootPart.Position,vector * 9e9)
						end
					end
				until not FLYING
				CONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
				lCONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
				SPEED = 0
				if not alreadyfixing then
					for i,v in pairs(RootPart:GetChildren()) do
						if v:IsA("BodyMover") then
							v:Destroy()
						end
					end
					RootPart.CFrame = CFrame.new(RootPart.Position)
				end
			end))
		end

		if Player.Name == Player.Name then

			local IYMouse = Player:GetMouse()

			IYMouse.KeyDown:connect(function(KEY)

				if KEY:lower() == 'w' then
					CONTROL.F = iyflyspeed
				elseif KEY:lower() == 's' then
					CONTROL.B = - iyflyspeed
				elseif KEY:lower() == 'a' then
					CONTROL.L = - iyflyspeed
				elseif KEY:lower() == 'd' then 
					CONTROL.R = iyflyspeed
				elseif KEY:lower() == 'e' then
					CONTROL.Q = iyflyspeed*2
				elseif KEY:lower() == 'q' then
					CONTROL.E = -iyflyspeed*2
				end
			end)

			IYMouse.KeyUp:connect(function(KEY)
				if KEY:lower() == 'w' then
					CONTROL.F = 0
				elseif KEY:lower() == 's' then
					CONTROL.B = 0
				elseif KEY:lower() == 'a' then
					CONTROL.L = 0
				elseif KEY:lower() == 'd' then
					CONTROL.R = 0
				elseif KEY:lower() == 'e' then
					CONTROL.Q = 0
				elseif KEY:lower() == 'q' then
					CONTROL.E = 0
				end
			end)

			FLY() 
		end
	end
end

local playerslist
game:GetService('RunService').Heartbeat:connect(function()
	chattween(ChatBlock,{CFrame=Character.HumanoidRootPart.CFrame*CFrame.new(4.13899994+math.sin(sine/30)/2,3.7516800022+math.sin(sine/20)/2,-3.51+math.sin(sine/40)/2)*CFrame.fromEulerAnglesYXZ(math.rad(-14.48+math.cos(sine/30)*10),math.rad(127+math.cos(sine/20)*10),math.rad(-3.97+math.cos(sine/40)*10))},0.5,Enum.EasingDirection.Out)

	if NetLagOthers == true then
		playerslist = game.Players:GetDescendants()
		for i, v in pairs(playerslist) do
			if v:IsA("Player") and v.Name ~= Player.Name then
				for i, v2 in pairs(workspace[v.Name]:GetDescendants()) do
					if v2:IsA("BasePart") then
						sethiddenproperty(v2, "NetworkIsSleeping", true)
					end
				end
			end
		end
	end

	if MuteOthers == true then
		playerslist = game.Players:GetDescendants()
		for i, v in pairs(playerslist) do
			if v:IsA("Player") and v.Name ~= Player.Name then
				for i, v2 in pairs(workspace[v.Name]:GetDescendants()) do
					if v2:IsA("Tool") then
						for c,m in pairs(v2:GetDescendants()) do
							if m:IsA("Sound") then
								m.Playing = false
							end
						end
					end
				end
			end
		end
		--[[
		for i,v in pairs(workspace:GetDescendants()) do
			if v:IsA("Sound") and v.Parent.Parent.Parent.Name ~= Player.Name and v.Parent.Parent:IsA("Tool") then
				v.Playing = false
			end
		end]]
	end

	if AudioReplication == true then
		ReplicationBoombox.Handle:FindFirstChild("Sound").Playing = true
	end

	for i, v in pairs(NominatedDeadChar:GetDescendants()) do
		if v:IsA("BasePart") then
			sethiddenproperty(v, "NetworkIsSleeping", false)
		end
		if v:IsA("Accessory") then
			sethiddenproperty(v.Handle, "NetworkIsSleeping", false)
		end
	end
end)

game:GetService("StarterGui"):SetCore("SendNotification",{
	Title = "IDHAN",
	Text = "Script load successful.",
	Button1 = "Okay"
})
